(function () {
    'use strict';

    angular
        .module('demoApp', ['ngMaterial', 'ngMessages', 'ngAnimate', 'restangular',
            'oitozero.ngSweetAlert', 'treasure-overlay-spinner', 'md.data.table',
            'angularMoment', 'angularInlineEdit'
        ])

        .constant('BASE_URL', window.location.origin)
        .constant('NAV_HEIGHT', 50)

        .config(["$mdThemingProvider", function ($mdThemingProvider) {
            $mdThemingProvider.theme('default')
                .primaryPalette('blue')
                .accentPalette('pink');
        }])

        .config(['RestangularProvider', function (RestangularProvider) {
            //set the base url for api calls on our RESTful services
            RestangularProvider.setBaseUrl(window.location.origin + '/api');
        }]);

}());


(function(){
'use strict';

angular.module('demoApp')
    .factory('webServices', ["webRequest", webServices]);

    function webServices(webRequest) {
        var service = {};

        /*
        * Meters
        */
        //service.getMeters = function (zoomLevel) {
        //    return webRequest.get('/api/meters');
        //};
        //
        //service.getMeterClustersByZoom = function (zoomLevel) {
        //    return webRequest.get('/api/meters/clusters/zoom/' + zoomLevel);
        //};
        //
        //service.getMeterClustersByZoomAndBounds = function (zoomLevel, bounds) {
        //    return webRequest.get('/api/meters/clusters/zoom/' + zoomLevel + '/bounds/' + bounds);
        //};
        //
        //service.getMetersWithinBounds = function (bounds) {
        //    return webRequest.get('/api/meters/bounds/' + bounds);
        //};
        //
        //service.getMetersByID = function (id) {
        //    return webRequest.get('/api/meters/' + id);
        //};
        //
        //service.getMetersBounds = function () {
        //  return webRequest.get('/api/meters/get_bounds');
        //};
        //
        //service.getMeterByMeterNo = function (meterNo) {
        //    return webRequest.get('/api/meters/get_by_meter_no/' + meterNo);
        //}

        return service;
    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .factory('sectionList', ['$rootScope', '$mdSidenav', 'gmapServices', 'Sections', 'blockList', sectionList]);

    function sectionList ($rootScope, $mdSidenav, gmapServices, Sections, blockList) {
        var service = {};

        service.polygoncolor = '#2c3e50';
        service.polygonOptions = {
            clickable: true,
            fillColor: service.polygoncolor,
            fillOpacity: 0,
            strokeColor: service.polygoncolor,
            strokeOpacity: 0.9,
            strokeWeight: 4,
            zIndex: 100
        };

        service.sections = [];

        service.loadSections = loadSections;
        service.add = add;

        function loadSections (loadForIndex) {
            var forIndex = loadForIndex || false;

            Sections.getList()
                .then(function(response){
                    response.forEach(function(section){
                        service.add(section, forIndex);
                    });
                }, function(error){
                    console.log('Error loading sections list: ',error);
                });
        }

        function add (sectionData, forIndex) {
            sectionData.polygon = createPolygon(sectionData, forIndex);

            blockList.loadBlocksForSection(sectionData, forIndex);

            service.sections.push(sectionData);
            return sectionData;
        }

        function createPolygon(section, forIndex) {
            var polygon = gmapServices.createCustomPolygon(section.area, service.polygonOptions);
                polygon.section = section;

            var adminHandler = function () {
                $mdSidenav('sectionDetailsSidenav')
                    .open()
                    .then(function () {
                        $rootScope.$broadcast('show-section-details', {section: section});
                    });
            };

            var indexHandler = function () {
                console.log('section polygon is clicked handler for index');
                $mdSidenav('sectionDetailsIndexSidenav')
                    .open()
                    .then(function () {
                        $rootScope.$broadcast('show-section-details', {section: section});
                    });
            };

            var handler = forIndex ? indexHandler : adminHandler;

            gmapServices.addListener(
                polygon,
                'click',
                function() {
                    gmapServices.setZoomIfGreater(21);
                    gmapServices.panToPolygon(polygon);
                    handler();
                }
            );

            return polygon;
        }

        return service;
    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .factory('modalServices', ['$mdDialog', '$mdMedia', '$rootScope', '$q', 'Settings', 'Clients', modalServices]);

    function modalServices ($mdDialog, $mdMedia, $rootScope, $q, Settings, Clients) {
        var service = {};

        service.customFullscreen = $mdMedia('sm') || $mdMedia('xs');

        service.settingsModal = null;
        service.showSettings = showSettings;

        service.addSectionModal = null;
        service.addBlockModal = null;
        service.addLotModal = null;

        service.showAddSection = showAddSection;
        service.showAddBlock = showAddBlock;
        service.showAddLot = showAddLot;

        service.showLotDetailModal = null;
        service.showLotDetail = showLotDetail;

        service.showClientSelectionModal = null;
        service.showClientSelection = showClientSelection;

        service.showAddOccupantModal = null;
        service.showAddOccupant = showAddOccupant;

        function showSettings(event) {
            var dfd = $q.defer();

            if (service.settingsModal) {
                dfd.reject('Modal already opened');
            } else {
                $rootScope.$broadcast("modal-opened");

                Settings.customGET('last_lot_price')
                    .then(function(lastLot){
                        console.log('get last lot price: ',lastLot);

                        service.settingsModal = $mdDialog.show({
                            controller: 'settingsController',
                            controllerAs: 'settingsCtl',
                            templateUrl: 'partials/modals/settings_dialog.tmpl.html',
                            parent: angular.element(document.body),
                            targetEvent: event,
                            locals: {lastLot: lastLot},
                            fullscreen: service.customFullscreen
                        });

                        service.settingsModal.then(
                            function (result) {
                                dfd.resolve(result);
                            }, function (reason) {
                                $rootScope.$broadcast('modal-dismissed');
                                dfd.reject(reason);
                            })
                            .finally(function () {
                                service.settingsModal = null;
                            });

                    }, function(er){
                        console.log('er: ',er);
                    });
            }
            return dfd.promise;
        }

        function showAddSection (event, sectionArea) {
            var dfd = $q.defer();

            if(service.addSectionModal) {
                dfd.reject('Modal already opened');
            } else {
                $rootScope.$broadcast("modal-opened");

                service.addSectionModal = $mdDialog.show({
                    controller: 'addSectionController',
                    controllerAs: 'addSectionCtl',
                    templateUrl: 'partials/modals/add_section_dialog.tmpl.html',
                    parent: angular.element(document.body),
                    locals: {area: sectionArea},
                    targetEvent: event,
                    fullscreen: service.customFullscreen
                });

                service.addSectionModal.then(
                   function(result) {
                    dfd.resolve(result);
                }, function (reason) {
                    $rootScope.$broadcast('modal-dismissed');
                    dfd.reject(reason);
                })
                .finally(function () {
                    service.addSectionModal = null;
                });
            }
            return dfd.promise;
        }

        function showAddBlock(event, section, sectionArea) {
            var dfd = $q.defer();

            if (service.addBlockModal) {
                dfd.reject('Modal already opened');
            } else {
                $rootScope.$broadcast("modal-opened");

                service.addBlockModal = $mdDialog.show({
                    controller: 'addBlockController',
                    controllerAs: 'addBlockCtl',
                    templateUrl: 'partials/modals/add_block_dialog.tmpl.html',
                    parent: angular.element(document.body),
                    locals: {section: section, area: sectionArea},
                    targetEvent: event,
                    fullscreen: service.customFullscreen
                });

                service.addBlockModal.then(
                    function (result) {
                        dfd.resolve(result);
                    }, function (reason) {
                        $rootScope.$broadcast('modal-dismissed');
                        dfd.reject(reason);
                    })
                    .finally(function () {
                        service.addBlockModal = null;
                    });
            }
            return dfd.promise;
        }

        function showAddLot(event, block, area) {
            var dfd = $q.defer();

            if (service.addLotModal) {
                dfd.reject('Modal already opened');
            } else {
                $rootScope.$broadcast("modal-opened");

                service.addLotModal = $mdDialog.show({
                    controller: 'addLotController',
                    controllerAs: 'addLotCtl',
                    templateUrl: 'partials/modals/add_lot_dialog.tmpl.html',
                    parent: angular.element(document.body),
                    locals: {block: block, area: area},
                    targetEvent: event,
                    fullscreen: service.customFullscreen
                });

                service.addLotModal.then(
                    function (result) {
                        dfd.resolve(result);
                    }, function (reason) {
                        $rootScope.$broadcast('modal-dismissed');
                        dfd.reject(reason);
                    })
                    .finally(function(){
                        service.addLotModal = null;
                    })
            }
            return dfd.promise;
        }

        function showLotDetail(lot) {
            var dfd = $q.defer();

            console.log('Show Lot Detail: ', lot);

            if (service.showLotDetailModal) {
                dfd.reject('Modal already opened');
            } else {
                $rootScope.$broadcast("modal-opened");

                lot.get().then(function(result){
                    service.showLotDetailModal = $mdDialog.show({
                        controller: 'lotDetailsController',
                        controllerAs: 'lotDetsCtl',
                        templateUrl: 'partials/modals/lot_details_dialog.tmpl.html',
                        parent: angular.element(document.body),
                        locals: {lot: result},
                        fullscreen: service.customFullscreen
                    });

                    service.showLotDetailModal.then(
                        function (result) {
                            dfd.resolve(result);
                        }, function (reason) {
                            $rootScope.$broadcast('modal-dismissed');
                            dfd.reject(reason);
                        })
                        .finally(function () {
                            service.showLotDetailModal = null;
                        })


                }, function(err){
                    console.log('Error: ',err);
                });

            }
            return dfd.promise;
        }

        function showClientSelection (lot) {
            var dfd = $q.defer();

            if (service.showClientSelectionModal) {
                dfd.reject('Modal already opened');
            } else {
                $rootScope.$broadcast("modal-opened");

                Clients.getList()
                    .then(function(resp) {

                        var clients = [];
                        resp.forEach(function(cl){
                           clients.push(cl);
                        });

                        console.log('Clients: ',resp);

                        service.showClientSelectionModal = $mdDialog.show({
                            controller: 'clientSelectionController',
                            controllerAs: 'clientSelectCtl',
                            templateUrl: 'partials/modals/lot_client_select_dialog.tmpl.html',
                            parent: angular.element(document.body),
                            locals: {lot: lot, clients: clients},
                            fullscreen: service.customFullscreen
                        });

                        service.showClientSelectionModal.then(
                            function (result) {
                                dfd.resolve(result);
                            }, function (reason) {
                                $rootScope.$broadcast('modal-dismissed');
                                dfd.reject(reason);
                            })
                            .finally(function () {
                                service.showClientSelectionModal = null;
                            });

                    }, function(err) {
                        console.log('Error fetching clients: ',err);
                    });
            }
            return dfd.promise;
        }

        function showAddOccupant(lot) {
            var dfd = $q.defer();

            if (service.showAddOccupantModal) {
                dfd.reject('Modal already opened');
            } else {
                $rootScope.$broadcast("modal-opened");

                service.showAddOccupantModal = $mdDialog.show({
                    controller: 'addLotOccupantController',
                    controllerAs: 'addLotOcptCtl',
                    templateUrl: 'partials/modals/add_lot_occupant_dialog.tmpl.html',
                    parent: angular.element(document.body),
                    locals: {lot: lot},
                    fullscreen: service.customFullscreen
                });

                service.showAddOccupantModal.then(
                    function (result) {
                        dfd.resolve(result);
                    }, function (reason) {
                        $rootScope.$broadcast('modal-dismissed');
                        dfd.reject(reason);
                    })
                    .finally(function () {
                        service.showAddOccupantModal = null;
                    });
            }
            return dfd.promise;
        }

        return service;
    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .factory('lotList', ['$rootScope', 'gmapServices', 'LOT_COLORS', 'Lots', 'modalServices', lotList]);

    function lotList ($rootScope, gmapServices, LOT_COLORS, Lots, modalServices) {
        var service = {};

        service.polygonColor = LOT_COLORS;
        service.polygonOptions = {
            clickable: true,
            fillOpacity: 0.8,
            strokeColor: '#000000',
            strokeOpacity: 0.6,
            strokeWeight: 1,
            zIndex: 101
        };

        service.lots = {};

        service.loadLotsForBlock = loadLotsForBlock;
        service.add = add;
        service.findLot = findLot;

        function init() {
            $rootScope.$on('lot-status-updated', function(event, params) {
                var lot = params.lot;
                var searchLot = _.where(service.lots[lot.block_id], {id: lot.id});
                //searchLot = lot;
                console.log('searchlot: ',searchLot);
            });
        }
        init();

        function loadLotsForBlock (block, forIndex) {
            console.log('load lots for block: ',block);

            if(!block.lots) return;

            block.lots.forEach(function(lot){
                service.add(block.id, lot, forIndex);
            });
        }

        function findLot(blockId, lotId) {
            return _.findWhere(service.lots[blockId], {id: lotId});
        }

        function add (blockId, data, forIndex) {
            if (!service.lots[blockId]) service.lots[blockId] = [];

            data.polygon = createPolygon(data, forIndex);

            service.lots[blockId].push(data);
        }

        function createPolygon(lot, forIndex) {
            var polygonColor = service.polygonColor[lot.status];
            var polygonOpts = angular.extend({}, service.polygonOptions, {
               fillColor: polygonColor
            });
            var polygon = gmapServices.createCustomPolygon(lot.area, polygonOpts);

            var restangularizedLot = Lots.cast(lot);

            var adminHandler = function () {
                console.log('admin handler for polygon click lot');
            };

            var indexHandler = function () {
                console.log('index handler for polygon click lot');
                // Show Lot Details
                // and option to change status and select client
                modalServices.showLotDetail(restangularizedLot)
                    .then( function (response) {

                    }, function(err) {

                    });
            };

            var handler = forIndex ? indexHandler : adminHandler;

            gmapServices.addListener(polygon, 'click', function() {
                gmapServices.setZoomIfGreater(21);
                gmapServices.panToPolygon(polygon);
                handler();
            });

            return polygon;
        }

        return service;
    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .factory('loaderServices', ['$rootScope', loaderServices]);

    function loaderServices ($rootScope) {
        var service = {};

        service.showLoader = showLoader;
        service.hideLoader = hideLoader;

        function showLoader () {
            $rootScope.spinner.active = true;
        }

        function hideLoader (_doApply) {
            var doApply = _doApply || false;
            if(doApply) {
                $rootScope.$apply(function () {
                    $rootScope.spinner.active = false;
                });
            } else {
                $rootScope.spinner.active = false;
            }
        }
        

        return service;
    }
}());
(function(){
    'use strict';

    angular.module('demoApp')
        .factory('gmapServices', ['$log', '$q', gmapServices]);

    function gmapServices($log, $q) {
        var service = {};

        //infowindow balloons
        service.INFO_WINDOWS = [];

        service.ZOOM_OUT_LEVEL = 8;
        service.ZOOM_IN_LEVEL = 19;

        service.map = null;
        service.mapProjection = null;
        service.overlayView = null;

        service.geocoder = null;

        service.markers = [];

        service.defaultZoom = service.ZOOM_IN_LEVEL;

        service.centerLatLng = new google.maps.LatLng(10.382237, 123.955110);

        // Cluster Objects
        // for Different Layers
        service.markerClusterers = {};

        // Maintain only one infobox
        // Prevent from opening multiple infoboxes
        service.lastInfoboxOpen = null;
        service.infoboxes = [];

        /**
         * Service Functions
         */
        service.apiAvailable = apiAvailable;
        service.createMap = createMap;
        service.createInfoBox = createInfoBox;
        service.openInfoBox = openInfoBox;
        service.closeInfoBox = closeInfoBox;
        service.closeAllInfoBox = closeAllInfoBox;
        service.setMapCursorCrosshair = setMapCursorCrosshair;
        service.setMapBounds = setMapBounds;
        service.getBoundsFromPath = getBoundsFromPath;
        service.setMapCursorDefault = setMapCursorDefault;
        service.addMapListener = addMapListener;
        service.getDistanceOfPath = getDistanceOfPath;
        service.fromLatLngToContainerPixel = fromLatLngToContainerPixel;
        service.fromLatLngToDivPixel = fromLatLngToDivPixel;
        service.fromLatLngToPoint = fromLatLngToPoint;
        service.createCoordinate = createCoordinate;
        service.createInfoWindow = createInfoWindow;
        service.createCanvasInfoWindow = createCanvasInfoWindow;
        service.hideCanvasInfoWindow = hideCanvasInfoWindow;
        service.showInfoWindow = showInfoWindow;
        service.hideInfoWindow = hideInfoWindow;
        service.clearInstanceListeners = clearInstanceListeners;
        service.initMarker = initMarker;
        service.createMarker = createMarker;
        service.createCustomMarker = createCustomMarker;
        service.createCircleMarker = createCircleMarker;
        service.panTo = panTo;
        service.panToOffsetLeft = panToOffsetLeft;
        service.showMarker = showMarker;
        service.showMarkers = showMarkers;
        service.hideMarker = hideMarker;
        service.hideMarkers = hideMarkers;
        service.destroyMarker = destroyMarker;
        service.destroyPolyline = destroyPolyline;
        service.centerMarker = centerMarker;
        service.setMapCenter = setMapCenter;
        service.setMapCenterDefault = setMapCenterDefault;
        service.setZoom = setZoom;
        service.setZoomIfGreater = setZoomIfGreater;
        service.setZoomDefault = setZoomDefault;
        service.setZoomInDefault = setZoomInDefault;
        service.createDrawingManager = createDrawingManager;
        service.createDrawingToolsManager = createDrawingToolsManager;
        service.showDrawingManager = showDrawingManager;
        service.hideDrawingManager = hideDrawingManager;
        service.setEnableDrawingManager = setEnableDrawingManager;
        service.changeDrawingManagerStrokeColor = changeDrawingManagerStrokeColor;
        service.createCircle = createCircle;
        service.updateCircle = updateCircle;
        service.initPolygon = initPolygon;
        service.createPolygon = createPolygon;
        service.createCustomPolygon = createCustomPolygon;
        service.updatePolygon = updatePolygon;
        service.showPolygon = showPolygon;
        service.hidePolygon = hidePolygon;
        service.resetPolygonFill = resetPolygonFill;
        service.fillPolygon = fillPolygon;
        service.panToPolygon = panToPolygon;
        service.setEditablePolygon = setEditablePolygon;
        service.createPolyline = createPolyline;
        service.createDashedPolyline = createDashedPolyline;
        service.updatePolyline = updatePolyline;
        service.showPolyline = showPolyline;
        service.hidePolyline = hidePolyline;
        service.addListener = addListener;
        service.addListenerOnce = addListenerOnce;
        service.clearInstanceListeners = clearInstanceListeners;
        service.clearListeners = clearListeners;
        service.removeListener = removeListener;
        service.trigger = trigger;
        service.showCurrentLocation = showCurrentLocation;
        service.reverseGeocode = reverseGeocode;
        service.loadKMLByURL = loadKMLByURL;
        service.initMapClusterer = initMapClusterer;
        service.destroyMapClusterer = destroyMapClusterer;
        service.createClusterMarker = createClusterMarker;
        service.getClustererInstance = getClustererInstance;
        service.clearClusterMarkers = clearClusterMarkers;
        service.resetClusters = resetClusters;
        service.insertImageMapType = insertImageMapType;
        service.removeOverlayAtIndex = removeOverlayAtIndex;
        service.initializeAutocomplete = initializeAutocomplete;
        service.containsLocation = containsLocation;
        service.triggerEvent = triggerEvent;

        function apiAvailable() {
            return typeof window.google === 'object';
        }

        function createMap(mapId, navHeight) {
            var _navHeight = navHeight || 0;

            var mapIdLoc = mapId || 'map3d';
            var myMapId = '#' + mapIdLoc;

            if (service.map) return service.map;
            if (!service.apiAvailable()) return null;

            var mapOptions = {
                zoom: service.defaultZoom,
                minZoom: 2,
                center: service.centerLatLng,
                mapTypeControl: false,
                mapTypeId: google.maps.MapTypeId.HYBRID,
                zoomControlOptions: {
                    position: google.maps.ControlPosition.RIGHT_BOTTOM
                },
                panControl: false,
                streetViewControl: false
            };

            $(myMapId).height($(window).height() - (_navHeight));

            service.map = new google.maps.Map(document.getElementById(mapIdLoc), mapOptions);

            // handle window resize event
            google.maps.event.addDomListener(window, 'resize', function () {
                $(myMapId).height($(window).height() - (_navHeight));
                var center = service.map.getCenter();
                google.maps.event.trigger(service.map, 'resize');
                service.map.setCenter(center);
            });

            return service.map;
        }

        function createInfoBox(template) {
            return new InfoBox({
                content: template || '',
                disableAutoPan: true,
                maxWidth: 0,
                pixelOffset: new google.maps.Size(25, -115),
                //closeBoxMargin: '15px 5px',
                closeBoxURL: 'static/resources/images/close-icon.png',
                isHidden: false,
                pane: 'floatPane',
                enableEventPropagation: true
            });
        }

        function openInfoBox(infobox, marker) {
            if( !(service.map && infobox && marker)) return;

            // Close last infobox open
            if (service.lastInfoboxOpen) service.lastInfoboxOpen.close();

            infobox.open(service.map, marker);

            service.lastInfoboxOpen = infobox;
            service.infoboxes.push(infobox);
        }

        function closeAllInfoBox() {
            service.infoboxes.forEach(function(infobox, index) {
               if(infobox) {
                   infobox.close();
               }
            });
        }

        function closeInfoBox() {
            if (service.lastInfoboxOpen) service.lastInfoboxOpen.close();
        }

        function addMapListener(eventName, callback) {
            if (service.map) {
                return service.addListener(service.map, eventName, callback);
            }
            return null;
        }

        function setMapCursorDefault() {
            if (service.map) service.map.setOptions({draggableCursor: null});
        }

        function setMapCursorCrosshair() {
            if (service.map) service.map.setOptions({draggableCursor: 'crosshair'});
        }

        function setMapBounds(bounds) {
            if (service.map) service.map.fitBounds(bounds);
        }

        function getBoundsFromPath(path) {
            if (!service.apiAvailable()) return null;
            var bounds = new google.maps.LatLngBounds();
            for (var index = 0; index < path.length; index++) {
                var point = path[index];
                bounds.extend(point);
            }
            return bounds;
        }

        function getDistanceOfPath(path) {
            if (!service.apiAvailable()) return 0;
            return google.maps.geometry.spherical.computeLength(path);
        }

        function fromLatLngToContainerPixel(latlng) {
            if (service.overlayView) {
                return service.overlayView.getProjection().fromLatLngToContainerPixel(latlng);
            }
            return new google.maps.Point();
        }

        function fromLatLngToDivPixel(latlng) {
            if (service.overlayView) {
                return service.overlayView.getProjection().fromLatLngToDivPixel(latlng);
            }
            return new google.maps.Point();
        }

        function fromLatLngToPoint(latlng) {
            if (service.map) {
                var numTiles = 1 << service.map.getZoom();
                var projection = new MercatorProjection();
                var worldCoordinate = projection.fromLatLngToPoint(latlng);
                return new google.maps.Point(
                    worldCoordinate.x * numTiles,
                    worldCoordinate.y * numTiles
                );
            } else {
                return new google.maps.Point();
            }
        }

        function createCoordinate(latitude, longitude) {
            return new google.maps.LatLng(latitude, longitude);
        }

        function createInfoWindow(content) {
            if (!service.apiAvailable()) return null;
            return new google.maps.InfoWindow({content: content});
        }

        function createCanvasInfoWindow() {
            if (!service.apiAvailable()) return null;

            return new CanvasInfoWindow(service.map);
        }

        function hideCanvasInfoWindow(infoWindow) {
            if (infoWindow) infoWindow.hideInfowindow();
        };

        function showInfoWindow(infoWindow, target) {
            if (infoWindow) infoWindow.open(service.map, target);
        }

        function hideInfoWindow(infoWindow) {
            if (infoWindow) infoWindow.close();
        }

        function clearInstanceListeners(_instance) {
            google.maps.event.clearInstanceListeners(_instance);
        }

        function initMarker(_position, _icon, _opts) {
            if (!service.apiAvailable()) return null;

            var additionalOpts = _opts || {};

            var opts = angular.extend({}, {
                position: _position,
                map: service.map,
                icon: _icon
            }, additionalOpts);

            return new google.maps.Marker(opts);
        }

        function createMarker(_position, _color) {
            _color = _color || service.MARKER_ICONS.RED;
            var marker = service.initMarker(_position, _color);

            service.markers.push(marker);

            return marker;
        }

        function createCustomMarker(_position, _icon, _opts) {
            var opts = _opts || {},
                icon = _icon || 'images/markers/default-marker.png';

            return service.initMarker(_position, icon, opts);
        }

        function createCircleMarker(_position, color) {
            var icon = {
                path: google.maps.SymbolPath.CIRCLE,
                scale: 5,
                fillColor: color || '#6ac1ff',
                fillOpacity: 1,
                strokeColor: 'black',
                strokeWeight: 1
            };

            var marker = service.initMarker(_position, icon);
            service.markers.push(marker);

            return marker;
        }

        function panTo(_position) {
            if (!service.map) return;

            service.map.panTo(_position);
        }

        function panToOffsetLeft(_position, _offset) {
            var offset = _offset || 0.013;
            var latLng = {};

            if(_position instanceof google.maps.LatLng) {
                console.log('object latlng');
                latLng.lat = _position.lat();
                latLng.lng = _position.lng() + offset;
            } else{
                latLng = _position;
                latLng.lng += offset;
            }

            this.panTo(latLng);
        }

        function showMarker(marker) {
            if (marker && marker instanceof google.maps.Marker) marker.setMap(service.map);
        }

        function showMarkers(markerArray) {
            markerArray.forEach(function (marker) {
                service.showMarker(marker);
            });
        }

        function hideMarker(marker) {
            if (marker && marker instanceof google.maps.Marker) marker.setMap(null);
        }

        function hideMarkers(markerArray) {
            markerArray.forEach( function(marker) {
                service.hideMarker(marker);
            });
        }

        function destroyPolyline(polyline) {
            if (polyline && polyline instanceof google.maps.Polyline) polyline.setMap(null);
            service.clearInstanceListeners(polyline);
            polyline = null;
        }

        function destroyMarker(marker) {
            if (marker instanceof Cluster) {
                marker.remove();
            }
            else if (marker instanceof google.maps.Marker) {
                service.hideMarker(marker);
                service.clearInstanceListeners(marker);
            }
            marker = null;
        }

        function centerMarker(marker) {
            if (service.map) {
                service.map.setCenter(marker.position);
            }
        }

        function setMapCenter(coordinates) {
            if (service.map) {
                service.map.setCenter(coordinates);
            }
        }

        function setMapCenterDefault() {
            service.setMapCenter(service.centerLatLng);
        }

        function setZoom(zoomValue) {
            if (service.map) {
                service.map.setZoom(zoomValue);
            }
        }

        function setZoomIfGreater(zoomValue) {
            if (zoomValue > service.map.getZoom())
                service.setZoom(zoomValue);
        }

        function setZoomDefault() {
            service.setZoom(service.defaultZoom);
        }

        function setZoomInDefault() {
            service.setZoom(service.ZOOM_IN_LEVEL);
        }

        function createDrawingManager(_color) {
            if (!service.apiAvailable()) return null;

            var strokeColor = _color || '#0000ff';

            var drawingManager = new google.maps.drawing.DrawingManager({
                drawingMode: null,
                drawingControl: true,
                drawingControlOptions: {
                    position: google.maps.ControlPosition.TOP_CENTER,
                    drawingModes: [
                        google.maps.drawing.OverlayType.POLYGON,
                        google.maps.drawing.OverlayType.RECTANGLE
                    ]
                },
                polygonOptions: {
                    clickable: true,
                    draggable: true,
                    editable: true,
                    geodesic: true,
                    fillColor: '#ffffff',
                    fillOpacity: 0,
                    strokeColor: strokeColor,
                    strokeOpacity: 0.9,
                    strokeWeight: 2,
                    zIndex: 1
                },
                rectangleOptions: {
                    clickable: true,
                    draggable: true,
                    editable: true,
                    fillColor: '#ffffff',
                    fillOpacity: 0,
                    strokeColor: strokeColor,
                    strokeOpacity: 0.9,
                    strokeWeight: 2,
                    zIndex: 1
                }
            });
            service.drawingManager = drawingManager;
            return drawingManager;
        }

        function changeDrawingManagerStrokeColor (color) {
            if (!service.apiAvailable() && !service.drawingManager) return null;

            var _color = color || '#0000ff';

            service.drawingManager.setOptions({
                polygonOptions: {
                    strokeColor: _color
                },
                rectangleOptions: {
                    strokeColor: _color
                }
            });

        }

        function createDrawingToolsManager() {
            if (!service.apiAvailable()) return null;
            var drawingManager = new google.maps.drawing.DrawingManager({
                drawingMode: null,
                drawingControl: true,
                drawingControlOptions: {
                    position: google.maps.ControlPosition.TOP_CENTER,
                    drawingModes: [
                        google.maps.drawing.OverlayType.MARKER,
                        google.maps.drawing.OverlayType.CIRCLE,
                        google.maps.drawing.OverlayType.POLYGON,
                        google.maps.drawing.OverlayType.POLYLINE,
                        google.maps.drawing.OverlayType.RECTANGLE
                    ]
                },
                markerOptions: {
                    icon: service.MARKER_ICONS.RED
                },
                circleOptions: {
                    clickable: true,
                    draggable: false,
                    editable: false,
                    fillColor: '#0000ff',
                    fillOpacity: 0.2,
                    strokeColor: '#0000ff',
                    strokeOpacity: 0.8,
                    strokeWeight: 1,
                    zIndex: 1
                },
                polygonOptions: {
                    clickable: true,
                    draggable: false,
                    editable: false,
                    geodesic: true,
                    fillColor: '#0000ff',
                    fillOpacity: 0.2,
                    strokeColor: '#0000ff',
                    strokeOpacity: 0.8,
                    strokeWeight: 1,
                    zIndex: 1
                },
                polylineOptions: {
                    clickable: true,
                    draggable: false,
                    editable: false,
                    strokeColor: '#0000ff',
                    strokeOpacity: 0.8,
                    strokeWeight: 1,
                    zIndex: 1
                },
                rectangleOptions: {
                    clickable: true,
                    draggable: false,
                    editable: false,
                    fillColor: '#0000ff',
                    fillOpacity: 0.2,
                    strokeColor: '#0000ff',
                    strokeOpacity: 0.8,
                    strokeWeight: 1,
                    zIndex: 1
                }
            });
            service.drawingManager = drawingManager;
            return drawingManager;
        }

        function showDrawingManager(drawingManager) {
            if (drawingManager) {
                if(!drawingManager.getMap()) {
                    drawingManager.setMap(service.map);
                }
                service.setEnableDrawingManager(drawingManager, true);
            }
        }

        function hideDrawingManager(drawingManager) {
            if (drawingManager) {
                drawingManager.setMap(null);
                service.setEnableDrawingManager(drawingManager, false);
            }
        }

        function setEnableDrawingManager(drawingManager, enabled) {
            if (drawingManager) {
                var drawingOptions = {drawingControl: enabled};
                // if drawing mode is disabled, set current mode to hand pointer.
                if (!enabled) drawingOptions['drawingMode'] = null;
                drawingManager.setOptions(drawingOptions);
            }
        }

        function createCircle(latitude, longitude, radius) {
            if (!service.apiAvailable()) return null;
            var latlng = new google.maps.LatLng(latitude, longitude);
            var circleOptions = {
                center: latlng,
                clickable: false,
                draggable: false,
                editable: false,
                fillColor: '#ffffff',
                fillOpacity: 0,
                map: service.map,
                radius: radius,
                strokeColor: '#0000ff',
                strokeOpacity: 0.9,
                strokeWeight: 2,
                zIndex: 100
            };
            return new google.maps.Circle(circleOptions);
        }

        function updateCircle(circle, latitude, longitude, radius) {
            if (circle) {
                circle.setCenter({lat: latitude, lng: longitude});
                circle.setRadius(radius);
            }
        }

        function initPolygon(path, color) {
            if (!service.apiAvailable()) return null;

            var defaultColor = color || '#0000ff';
            var polygonOptions = {
                path: path,
                clickable: false,
                draggable: false,
                editable: false,
                fillColor: defaultColor,
                fillOpacity: 0,
                strokeColor: defaultColor,
                strokeOpacity: 0.9,
                strokeWeight: 2,
                zIndex: 100
            };

            return new google.maps.Polygon(polygonOptions);
        }

        function createCustomPolygon(path, opts) {
            var _opts = {
                path: path,
                map: service.map
            };
            angular.merge(_opts, opts);
            return new google.maps.Polygon(_opts);
        }

        function createPolygon(path, color) {
            var polygon = service.initPolygon(path, color);

            polygon.setMap(service.map);

            return polygon;
        }

        function updatePolygon(polygon, path) {
            if (polygon) polygon.setPath(path);
        }

        function showPolygon(polygon) {
            if (polygon) polygon.setMap(service.map);
        }

        function hidePolygon(polygon) {
            if (polygon) polygon.setMap(null);
        }

        function resetPolygonFill(polygon) {
            polygon.setOptions({
                fillOpacity: 0
            });
        }

        function fillPolygon(polygon) {
            polygon.setOptions({
                fillOpacity: 0.5
            });
        }

        function panToPolygon(polygon) {
            if (!service.map || !polygon) return;

            var bounds = new google.maps.LatLngBounds();

            polygon.getPath().forEach( function(path){
                bounds.extend(path);
            });

            service.panTo(bounds.getCenter());
        }

        function setEditablePolygon (polygon, flag) {
            var isEditable = flag !== false;

            polygon.setOptions({editable: isEditable, draggable: isEditable});
        }

        function createPolyline(path, lineColor) {
            if (!service.apiAvailable()) return null;
            var polylineOptions = {
                path: path,
                clickable: true,
                draggable: false,
                editable: false,
                map: service.map,
                strokeColor: lineColor || '#ff0000',
                strokeOpacity: 1,
                strokeWeight: 2,
                zIndex: 100
            };
            return new google.maps.Polyline(polylineOptions);
        }

        function createDashedPolyline(path, lineColor) {
            if (!service.apiAvailable()) return null;

            var lineSymbol = {
                path: 'M 0,-1 0,1',
                strokeOpacity: 1,
                scale: 1
            };

            var polylineOptions = {
                path: path,
                clickable: true,
                draggable: false,
                editable: false,
                map: service.map,
                strokeColor: lineColor || '#ff0000',
                icons: [{
                    icon: lineSymbol,
                    offset: '0',
                    repeat: '3px'
                }],
                strokeOpacity: 0,
                zIndex: 100
            };
            return new google.maps.Polyline(polylineOptions);
        }

        function updatePolyline(polyline, path) {
            if (polyline) polyline.setPath(path);
        }

        function showPolyline(polyline) {
            if (polyline) polyline.setMap(service.map);
        }

        function hidePolyline(polyline) {
            if (polyline) polyline.setMap(null);
        }

        function addListener(instance, eventName, handler) {
            if (!service.apiAvailable()) return null;
            return google.maps.event.addListener(instance, eventName, handler);
        }

        function addListenerOnce(instance, eventName, handler, capture) {
            if (!service.apiAvailable()) return null;
            return google.maps.event.addListenerOnce(instance, eventName, handler, capture);
        }

        function clearInstanceListeners(instance) {
            if (service.apiAvailable())
                google.maps.event.clearInstanceListeners(instance);
        }

        function clearListeners(instance, eventName) {
            if (service.apiAvailable())
                google.maps.event.clearListeners(instance, eventName);
        }

        function removeListener(listener) {
            if (service.apiAvailable())
                google.maps.event.removeListener(listener);
        }

        function trigger(instance, eventName, args) {
            if (service.apiAvailable())
                google.maps.event.trigger(instance, eventName, args);
        }

        function showCurrentLocation(_latLng, _isDraggable) {
            var icon = '/images/markers/current-location.png';
            var isDraggable = _isDraggable || false;

            return service.createCustomMarker(_latLng, icon, {draggable: isDraggable});
        }

        function reverseGeocode(latLng) {
            if (!service.geocoder) return;

            var dfd = $q.defer();

            service.geocoder.geocode({'latLng': latLng}, function (results, status) {
                if (status == google.maps.GeocoderStatus.OK) {
                    dfd.resolve(results);
                } else {
                    var error = "Geocoder failed due to: " + status;
                    $log.error(error);
                    dfd.reject(error);
                }
            });

            return dfd.promise;
        }

        function loadKMLByURL(srcUrl, kmlOptions) {
            if (service.map) {
                var opt = {
                    url: srcUrl,
                    map: service.map,
                    preserveViewport: true
                };

                if (kmlOptions) {
                    opt = angular.extend({}, opt, kmlOptions);
                }

                return new google.maps.KmlLayer(opt);
            }
            return null;
        }

        function loadClusterStyles(layerName) {
            var defaultStyle = 'resources/images/cluster_icons/m';

            if(layerName == 'meters') {
                return defaultStyle;
            } else if(layerName == 'transformers') {
                return 'resources/images/cluster_icons/transformers/m';
            } else if(layerName == 'poles') {
                return 'resources/images/cluster_icons/poles/m';
            }
            return defaultStyle;
        }

        function initMapClusterer(layerName) {
            if (!service.markerClusterers[layerName]) {
                var clusterStyle = loadClusterStyles(layerName);

                service.markerClusterers[layerName] = new MarkerClusterer(service.map, [],
                    {imagePath: clusterStyle});

                return service.markerClusterers[layerName];
            }
            return null;
        }

        function destroyMapClusterer(layerName) {
            if (service.markerClusterers[layerName]) {
                service.markerClusterers[layerName] = null;
            }
        }

        function createClusterMarker(_position, clusterCount, layerName) {
            if (!service.apiAvailable() || !service.markerClusterers[layerName]) return null;

            var latLngObj = new google.maps.LatLng(_position.lat, _position.lng)
            var cluster = new Cluster(service.markerClusterers[layerName]);

            cluster.center_ = latLngObj;

            cluster.clusterIcon_.setCenter(latLngObj);
            cluster.clusterIcon_.setSums({text: clusterCount, index: Math.round(Math.log(clusterCount) / Math.LN10)});
            cluster.clusterIcon_.textColor_ = 'white';
            cluster.clusterIcon_.show();
            cluster.clusterIcon_.triggerClusterClick = function () {
                var currentZoom = service.map.getZoom();
                service.map.setZoom(++currentZoom);
                service.map.setCenter(cluster.center_);
            };

            return cluster;
        }

        function getClustererInstance(layerName) {
            return service.markerClusterers[layerName];
        }

        function clearClusterMarkers(clusterArray) {
            clusterArray.forEach(function (item, index) {
                if (item instanceof Cluster) {
                    item.remove();
                }
                clusterArray[index] = null;
            });
        }

        function resetClusters(layerName) {
            if (service.markerClusterers[layerName]) {
                service.markerClusterers[layerName].clusters_ = [];
            }
        }

        function insertImageMapType(srcUrl, insertIndex) {
            if (!service.apiAvailable()) return;

            var _insertIndex = insertIndex || 0;

            var imageTile = new google.maps.ImageMapType({
                getTileUrl: function (coord, zoom) {
                    var z2 = Math.pow(2, zoom);
                    var y = coord.y,
                        x = coord.x >= 0 ? coord.x : z2 + coord.x

                    return srcUrl + '/' + zoom + "/" + x + "/" + y + ".png";
                },
                tileSize: new google.maps.Size(256, 256),
                isPng: true,
                opacity: 1.0
            });

            service.map.overlayMapTypes.insertAt(_insertIndex, imageTile);

            return _insertIndex;
        }

        function removeOverlayAtIndex(index) {
            service.map.overlayMapTypes.setAt(index, null);
        }

        function initializeAutocomplete(elementId) {
            var input = document.getElementById(elementId);
            var autocomplete = new google.maps.places.Autocomplete(input, {
                types: ["geocode"]
            });

            autocomplete.bindTo('bounds', service.map);

            return autocomplete;
        }

        function containsLocation (latLng, polygon) {
            if(!polygon) return;

            return google.maps.geometry.poly.containsLocation(latLng, polygon);
        }

        function triggerEvent (obj, event) {
            google.maps.event.trigger(obj, event);
        }

        return service;
    }
}());


(function () {
    'use strict';

    angular.module('demoApp')
        .factory('drawingServices', ['gmapServices', '$rootScope', drawingServices]);

    function drawingServices(gmapServices, $rootScope) {

        var service = {};
        service.drawingManager = null;
        service.drawingCompleteListener = null;

        service.overlay = null;
        service.overlayType = '';
        service.overlayDataArray = [];

        service.strokeColor = '';

        /**
         * Functions
         */
        service.initDrawingManager = initDrawingManager;
        service.initDrawingListener = initDrawingListener;
        service.setPanControl = setPanControl;
        service.hideDrawingManager = hideDrawingManager;
        service.startDrawingMode = startDrawingMode;
        service.setListenerOfType = setListenerOfType;
        service.stopDrawingMode = stopDrawingMode;
        service.hideOverlay = hideOverlay;
        service.clearOverlay = clearOverlay;
        service.getAreaCoords = getAreaCoords;
        service.getAreaFormData = getAreaFormData;
        service.getPolygonCoords = getPolygonCoords;
        service.getRectangleCorners = getRectangleCorners;
        service.getRectangleCoords = getRectangleCoords;


        function initDrawingManager() {
            if (service.drawingManager) {
                if(service.overlayStrokeColor) gmapServices.changeDrawingManagerStrokeColor(service.overlayStrokeColor);

                // Reinitialize Drawing Listener
                service.initDrawingListener();
                return;
            }

            service.drawingManager = gmapServices.createDrawingManager(service.overlayStrokeColor);
            service.initDrawingListener();
        }


        function initDrawingListener() {
            if (!service.drawingManager) return;

            if (service.drawingCompleteListener) return;

            service.drawingCompleteListener = gmapServices.addListener(
                service.drawingManager, 'overlaycomplete', overlayCompleteListener);
        }


        function overlayCompleteListener(eventArgs) {
            // Set only one overlay
            if (service.overlay) {
                service.overlay.setMap(null);
                service.overlay = null;
                service.overlayDataArray = [];
            }

            service.overlay = eventArgs.overlay;
            service.overlay.setMap(gmapServices.map);

            service.overlayType = eventArgs.type;
            service.overlayDataArray = service.getAreaCoords();

            // Add Listener when overlay is resized
            service.setListenerOfType(eventArgs, function (args) {
                service.overlay = args.overlay;
                service.overlayType = args.type;
                service.overlayDataArray = service.getAreaCoords();
            });

            // Set control to pan every after drawing
            service.setPanControl();

            $rootScope.$broadcast('overlay-complete');
        }


        function setPanControl() {
            service.drawingManager.setDrawingMode(null);
        }


        function hideDrawingManager() {
            if (service.drawingManager) {
                gmapServices.hideDrawingManager(service.drawingManager);
            }
        }

        function startDrawingMode(strokeColor) {
            if(strokeColor) service.overlayStrokeColor = strokeColor;

            service.initDrawingManager();

            gmapServices.showDrawingManager(service.drawingManager);
        }

        function setListenerOfType(eArgs, callbackFn) {
            switch (eArgs.type) {
                // Add Listener Events For Rectangle Changed
                case google.maps.drawing.OverlayType.RECTANGLE:
                    google.maps.event.addListener(eArgs.overlay, 'bounds_changed', function () {
                        callbackFn(eArgs);
                    });
                    break;
                // Add Listener Events For Polygon Changed
                case google.maps.drawing.OverlayType.POLYGON:
                    google.maps.event.addListener(eArgs.overlay.getPath(), 'set_at', function () {
                        callbackFn(eArgs);
                    });
                    google.maps.event.addListener(eArgs.overlay.getPath(), 'insert_at', function (e) {
                        callbackFn(eArgs);
                    });
            }
        }

        function stopDrawingMode() {
            if (service.drawingCompleteListener) {
                gmapServices.removeListener(service.drawingCompleteListener);
                service.drawingCompleteListener = null;
            }

            service.hideDrawingManager();

            service.hideOverlay();
        }

        function cancelDrawingMode() {
            service.stopDrawingMode();
        }

        function hideOverlay() {
            if (!service.overlay) return;

            service.overlay.setMap(null);
            service.overlay = null;
        }

        function clearOverlay() {
            hideOverlay();

            service.overlayDataArray = [];
            service.overlayType = '';
        }

        function getAreaCoords() {
            if (service.overlayType == google.maps.drawing.OverlayType.POLYGON) {
                return service.getPolygonCoords();
            }
            else if (service.overlayType == google.maps.drawing.OverlayType.RECTANGLE) {
                return service.getRectangleCorners();
            }

            return [];
        }

        function getPolygonCoords(_polygon) {
            var polygon = _polygon || service.overlay;

            if (!polygon) return;

            var path = polygon.getPath().getArray();
            var data = [];

            for (var index in path) {
                data.push({
                    lat: path[index].lat(),
                    lng: path[index].lng()
                });
            }

            return data;
        }

        function getAreaFormData(_area) {
            return getPolygonCoords(_area);
        }

        function getRectangleCorners(_rect) {
            var rect = _rect || service.overlay;

            if (!rect) return;

            var bounds = rect.getBounds();
            var min = bounds.getNorthEast();
            var max = bounds.getSouthWest();
            var data = [];

            data.push({lat: min.lat(), lng: min.lng()});
            data.push({lat: max.lat(), lng: min.lng()});
            data.push({lat: max.lat(), lng: max.lng()});
            data.push({lat: min.lat(), lng: max.lng()});

            return data;
        }

        function getRectangleCoords() {
            if (!service.overlay) return;

            var bounds = service.overlay.getBounds();
            var min = bounds.getNorthEast(),
                max = bounds.getSouthWest();
            var data = [];

            data.push({lat: min.lat(), lng: min.lng()});
            data.push({lat: max.lat(), lng: max.lng()});

            return data;
        }

        return service;
    }

}());

(function(){
'use strict';

angular.module('demoApp')
    .factory('blockList', ['$rootScope', 'gmapServices', '$mdSidenav', 'lotList', blockList]);

    function blockList ($rootScope, gmapServices, $mdSidenav, lotList) {
        var service = {};

        service.polygoncolor = '#ecf0f1';
        service.polygonOptions = {
            clickable: true,
            fillColor: service.polygoncolor,
            fillOpacity: 0,
            strokeColor: service.polygoncolor,
            strokeOpacity: 0.9,
            strokeWeight: 2,
            zIndex: 101
        };

        service.blocks = {};

        service.loadBlocksForSection = loadBlocksForSection;
        service.add = add;

        function loadBlocksForSection (section, forIndex) {
            if(!section.blocks) return;

            section.blocks.forEach(function(block){
                service.add(section.id, block, forIndex);
            });
        }

        function add (sectionId, data, forIndex) {
            if (!service.blocks[sectionId]) service.blocks[sectionId] = [];

            data.polygon = createPolygon(data, forIndex);

            lotList.loadLotsForBlock(data, forIndex);

            service.blocks[sectionId].push(data);
        }

        function createPolygon(block, forIndex) {
            var polygon = gmapServices.createCustomPolygon(block.area, service.polygonOptions);

            var adminHandler = function () {
                console.log('admin handler for polygon click block');
            };

            var indexHandler = function () {
                console.log('index handler for polygon click block');
                $mdSidenav('blockDetailsIndexSidenav')
                    .open()
                    .then(function () {
                        $rootScope.$broadcast('show-block-details', {block: block});
                    });
            };

            var handler = forIndex ? indexHandler : adminHandler;

            gmapServices.addListener(polygon, 'click', function() {
                gmapServices.setZoomIfGreater(21);
                gmapServices.panToPolygon(polygon);
                handler();
            });

            return polygon;
        }

        return service;
    }
}());
(function () {
'use strict';

angular.module('demoApp')
    .factory('alertServices', ['$mdToast', 'SweetAlert', alertServices]);

    function alertServices($mdToast, SweetAlert) {
        var service = {};

        service.showTopRightToast = showTopRightToast;
        service.showLotAdded = showLotAdded;
        service.settingsSuccessfullySaved = settingsSuccessfullySaved;
        service.showErrorMessage = showErrorMessage;

        function showTopRightToast(message) {
            $mdToast.show(
                $mdToast.simple()
                    .textContent(message)
                    .position('top right')
                    .hideDelay(2000)
            );
        }

        function showLotAdded () {
            service.showTopRightToast('Lot Added.');
        }

        function settingsSuccessfullySaved () {
            SweetAlert.swal({
                title: 'Settings Updated!',
                type: 'success'
            });
        }

        function showErrorMessage (error) {
            SweetAlert.swal({
                title: error,
                type: 'error'
            });
        }

        return service;
    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .factory('Settings', ['Restangular', Settings]);

    function Settings(Restangular) {
        var resourceModel = Restangular.all('settings');

        Restangular.extendModel('settings', function (model) {

            model.getLastLotPrice = function () {
                return model
                    .customGET('lastLot_price');
            };

            return model;
        });


        return resourceModel;
    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .factory('Sections', ['Restangular', Sections]);

    function Sections(Restangular) {
        var resourceModel = Restangular.all('sections');

        Restangular.extendModel('sections', function (model) {

            model.addBlock = function (block) {
                return model
                    .all('blocks')
                    .customPOST(block);
            };

            return model;
        });

        return resourceModel;
    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .factory('Lots', ['Restangular', Lots]);

    function Lots(Restangular) {
        var model = Restangular.all('lots');

        return angular.extend(model, {
            cast: function(lot) {
              lot.polygon = null;
              return Restangular.restangularizeElement(null, lot, 'lots');
            }
        });
    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .factory('Clients', ['Restangular', Clients]);

    function Clients(Restangular) {
        var model = Restangular.all('clients');

        return angular.extend(model, {
            cast: function(client) {
              return Restangular.restangularizeElement(null, client, 'clients');
            }
        });
    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .factory('Blocks', ['Restangular', Blocks]);

    function Blocks(Restangular) {
        var model = Restangular.all('blocks');

        return angular.extend(model, {
            cast: function(block) {
              block.polygon = null;
              return Restangular.restangularizeElement(null, block, 'blocks');
            }
        });
    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .controller('settingsController', ['$mdDialog', 'Settings', 'alertServices', 'lastLot', settingsController]);

    function settingsController ($mdDialog, Settings, alertServices, lastLot) {
        var vm = this;

        vm.settings = {
            price_per_sq_mtr: ''
        };

        vm.lastLotPrice = {};

        vm.initialize = initialize;
        vm.save = save;
        vm.cancel = cancel;

        vm.initialize();

        /* Controller Functions here */

        function initialize () {
            vm.lastLotPrice = lastLot;
            console.log('lastLotPrice: ',vm.lastLotPrice);
        }

        function save () {
            Settings.post(vm.settings)
                .then(function (response) {
                    console.log('Success saving settings: ',response);
                    alertServices.settingsSuccessfullySaved();
                    $mdDialog.hide(response);
                }, function (error) {
                    console.log('Error: ', error);
                    // Show Errors
                });
        }

        function cancel () {
            $mdDialog.cancel();
        }

        /* Non Scope Functions here */

    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .controller('sectionDetailsIndexController', ['$rootScope', '$mdSidenav', 'sectionList', 'blockList', 'lotList', 'gmapServices', 'drawingServices', 'modalServices', sectionDetailsIndexController]);

    function sectionDetailsIndexController ($rootScope, $mdSidenav, sectionList, blockList, lotList, gmapServices, drawingServices, modalServices) {
        var vm = this;

        vm.lastPolygon = null;

        vm.editMode = false;
        vm.tempSection = {
            name: null,
            polygon: null,
            area: []
        };

        var saveListener = {
            block: null,
            lot: null
        };

        vm.section = {
          id: '',
          name: '',
          blocks: [],
          area: []
        };

        vm.sectionInfo = {
            lotCount: 0,
            soldLot: 0,
            unsoldLot: 0
        };


        vm.initialize = initialize;
        vm.close = close;

        vm.editSection = editSection;
        vm.saveChanges = saveChanges;

        vm.addBlock = addBlock;
        vm.showBlock = showBlock;

        vm.addLot = addLot;

        vm.initialize();

        /* Controller Functions here */

        function initialize () {
            $rootScope.$on('show-section-details', function(event, params){
                vm.editMode = false;
                vm.section = params.section;
                vm.tempSection.name = params.section.name;

                updateSectionDetails(vm.section);

                gmapServices.hidePolygon(vm.section.polygon);

                if(vm.lastPolygon) {
                    gmapServices.setEditablePolygon(vm.lastPolygon, false);
                    gmapServices.showPolygon(vm.lastPolygon)
                }

                vm.lastPolygon = vm.section.polygon;

                if(vm.tempSection.polygon) {
                    gmapServices.hidePolygon(vm.tempSection.polygon);
                    vm.tempSection.polygon = null;
                }

                vm.tempSection.polygon = gmapServices.createCustomPolygon(vm.section.area, sectionList.polygonOptions);
            });
        }

        function updateSectionDetails (section) {
            console.log('section details: ',section);
            section.blocks.forEach(function(blk){
                vm.sectionInfo.lotCount += blk.lots.length;
                vm.sectionInfo.soldLot += _.where(blk.lots, {status: 'sold'}).length;
                vm.sectionInfo.soldLot += _.where(blk.lots, {status: 'occupied'}).length;
                vm.sectionInfo.unsoldLot += _.where(blk.lots, {status: 'vacant'}).length;
            });
        }

        /* Section Functions */

        function editSection () {
            toggle(true);
        }

        function saveChanges () {
            toggle(false);
            vm.tempSection.area = drawingServices.getPolygonCoords(vm.tempSection.polygon);

            // to avoid this error "TypeError: Converting circular structure to JSON"
            vm.section.polygon = null;

            vm.section.area = vm.tempSection.area;
            vm.section.name = vm.tempSection.name;

            vm.section.put()
                .then(function(response){
                    gmapServices.hidePolygon(vm.tempSection.polygon);
                    vm.tempSection.polygon = null;
                    vm.lastPolygon = null;

                    vm.section.polygon = gmapServices.createCustomPolygon(vm.section.area, sectionList.polygonOptions);

                }, function(error){
                    console.log('failed updating section: ',error);
                });
        }

        /* End Section Functions */


        /* Block Functions */

        function addBlock(ev) {
            $rootScope.$broadcast('start-drawing');
            drawingServices.startDrawingMode('#e74c3c');

            saveListener.block = $rootScope.$on('save-area', function (event, param) {
                modalServices.showAddBlock(ev, vm.section, param.area)
                    .then(function (result) {
                        blockList.add(result.block.section_id, result.block);
                        vm.section.blocks.push(result.block);
                    }, function (reason) {
                        console.log('failed: ', reason);
                    })
                    .finally(function(){
                        // destroy listener
                        saveListener.block();
                        saveListener.block = null;
                    });
            });
        }

        function showBlock(block) {
            gmapServices.setZoomIfGreater(21);
            gmapServices.panToPolygon(block.polygon);
        }

        /* End of Block Functions */

        /* Lot Functions */

        function addLot(ev, block) {
            $rootScope.$broadcast('start-drawing');
            drawingServices.startDrawingMode('#2ecc71');

            console.log('Block: ',block);

            saveListener.lot = $rootScope.$on('save-area', function (event, param) {
                modalServices.showAddLot(ev, block, param.area)
                    .then(function (result) {
                        lotList.add(block.id, result.lot);
                        block.lots.push(result.lot);
                    }, function (reason) {
                        console.log('failed: ', reason);
                    })
                    .finally(function () {
                        // destroy listener
                        saveListener.lot();
                        saveListener.lot = null;
                    });
            });
        }

        /* End of Lot Functions */


        function toggle(flag) {
            vm.editMode = flag;
            gmapServices.setEditablePolygon(vm.tempSection.polygon, flag);
        }

        vm.openBlockMenu = openBlockMenu;
        var originatorEv;

        function openBlockMenu($mdOpenMenu, ev) {
            originatorEv = ev;
            $mdOpenMenu(ev);
        };

        function close () {
            $mdSidenav('sectionDetailsSidenav')
                .close()
                //.then(function(){
                //    vm.section = {
                //        id: '',
                //        name: '',
                //        area: []
                //    };
                //})
            ;
        }

    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .controller('sectionDetailsController', ['$rootScope', '$mdSidenav', 'sectionList', 'blockList', 'lotList', 'gmapServices', 'drawingServices', 'modalServices', sectionDetailsController]);

    function sectionDetailsController ($rootScope, $mdSidenav, sectionList, blockList, lotList, gmapServices, drawingServices, modalServices) {
        var vm = this;

        vm.lastPolygon = null;

        vm.editMode = false;
        vm.tempSection = {
            name: null,
            polygon: null,
            area: []
        };

        var saveListener = {
            block: null,
            lot: null
        };

        vm.section = {
          id: '',
          name: '',
          blocks: [],
          area: []
        };


        vm.initialize = initialize;
        vm.close = close;

        vm.editSection = editSection;
        vm.saveChanges = saveChanges;

        vm.addBlock = addBlock;
        vm.showBlock = showBlock;

        vm.addLot = addLot;

        vm.initialize();

        /* Controller Functions here */

        function initialize () {
            $rootScope.$on('show-section-details', function(event, params){
                vm.editMode = false;
                vm.section = params.section;
                vm.tempSection.name = params.section.name;

                gmapServices.hidePolygon(vm.section.polygon);

                if(vm.lastPolygon) {
                    gmapServices.setEditablePolygon(vm.lastPolygon, false);
                    gmapServices.showPolygon(vm.lastPolygon)
                }

                vm.lastPolygon = vm.section.polygon;

                if(vm.tempSection.polygon) {
                    gmapServices.hidePolygon(vm.tempSection.polygon);
                    vm.tempSection.polygon = null;
                }

                vm.tempSection.polygon = gmapServices.createCustomPolygon(vm.section.area, sectionList.polygonOptions);
            });
        }

        /* Section Functions */

        function editSection () {
            toggle(true);
        }

        function saveChanges () {
            toggle(false);
            vm.tempSection.area = drawingServices.getPolygonCoords(vm.tempSection.polygon);

            // to avoid this error "TypeError: Converting circular structure to JSON"
            vm.section.polygon = null;

            vm.section.area = vm.tempSection.area;
            vm.section.name = vm.tempSection.name;

            vm.section.put()
                .then(function(response){
                    gmapServices.hidePolygon(vm.tempSection.polygon);
                    vm.tempSection.polygon = null;
                    vm.lastPolygon = null;

                    vm.section.polygon = gmapServices.createCustomPolygon(vm.section.area, sectionList.polygonOptions);

                }, function(error){
                    console.log('failed updating section: ',error);
                });
        }

        /* End Section Functions */


        /* Block Functions */

        function addBlock(ev) {
            $rootScope.$broadcast('start-drawing');
            drawingServices.startDrawingMode('#e74c3c');

            saveListener.block = $rootScope.$on('save-area', function (event, param) {
                modalServices.showAddBlock(ev, vm.section, param.area)
                    .then(function (result) {
                        blockList.add(result.block.section_id, result.block);
                        vm.section.blocks.push(result.block);
                    }, function (reason) {
                        console.log('failed: ', reason);
                    })
                    .finally(function(){
                        // destroy listener
                        saveListener.block();
                        saveListener.block = null;
                    });
            });
        }

        function showBlock(block) {
            gmapServices.setZoomIfGreater(21);
            gmapServices.panToPolygon(block.polygon);
        }

        /* End of Block Functions */

        /* Lot Functions */

        function addLot(ev, block) {
            $rootScope.$broadcast('start-drawing');
            drawingServices.startDrawingMode('#2ecc71');

            console.log('Block: ',block);

            saveListener.lot = $rootScope.$on('save-area', function (event, param) {
                modalServices.showAddLot(ev, block, param.area)
                    .then(function (result) {
                        lotList.add(block.id, result.lot);
                        block.lots.push(result.lot);
                    }, function (reason) {
                        console.log('failed: ', reason);
                    })
                    .finally(function () {
                        // destroy listener
                        saveListener.lot();
                        saveListener.lot = null;
                    });
            });
        }

        /* End of Lot Functions */


        function toggle(flag) {
            vm.editMode = flag;
            gmapServices.setEditablePolygon(vm.tempSection.polygon, flag);
        }

        vm.openBlockMenu = openBlockMenu;
        var originatorEv;

        function openBlockMenu($mdOpenMenu, ev) {
            originatorEv = ev;
            $mdOpenMenu(ev);
        };

        function close () {
            $mdSidenav('sectionDetailsSidenav')
                .close()
                //.then(function(){
                //    vm.section = {
                //        id: '',
                //        name: '',
                //        area: []
                //    };
                //})
            ;
        }

    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .controller('mainController', ['$rootScope', 'BASE_URL', 'modalServices', mainController]);

    function mainController ($rootScope, BASE_URL, modalServices) {
        var vm = this;

        $rootScope.spinner = {
            active: false
        };

        vm.menu = [
            {
                link: '/admin',
                title: 'Admin',
                icon: 'group'
            },
            {
                title: 'Settings',
                icon: 'settings'
            },
            {
                link: '/logout',
                title: 'Logout',
                icon: 'exit_to_app'
            }
        ];

        //vm.initialize = initialize;
        vm.redirect = redirect;
        vm.openSettings = openSettings;

        //vm.initialize();
        //
        //function initialize () {
        //    sectionList.loadSections(); // Transferred to Admin Controller
        //}

        function redirect(e, link) {
            e.preventDefault();

            if(link == '/admin'  || link == '/logout') {
                console.log('link: ', link);
                window.location = BASE_URL + link;
                return;
            }

            vm.openSettings(e);
        }

        function openSettings (e) {
            modalServices.showSettings(e);
        }

    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .controller('lotListController', ['$rootScope', '$filter', 'Lots', 'lotList', 'gmapServices', lotListController]);

    function lotListController($rootScope, $filter, Lots, lotList, gmapServices) {
        var vm = this;

        // complete list of Solars from the server
        $rootScope.lotList = [];

        vm.query = {
            order: 'status',
            limit: 10,
            page: 1,
            filter: ''
        };

        vm.filter = {
            show: false,
            form: null
        };

        vm.searchFilters = {
            '$': ''
        };

        // Table Header
        vm.tableHeaderList = ['Lot No.', 'Dimension', 'Area', 'Price/SM', 'Amount', 'Remarks', 'Owner', 'Date Purchased'];

        vm.initialize = initialize;
        vm.close = close;
        vm.onClickRow = onClickRow;
        vm.onReorder = onReorder;
        vm.removeFilter = removeFilter;

        vm.initialize();

        function initialize() {
            loadLots();

            //$scope.$watch(angular.bind(vm, function () {
            //    return vm.query.filter;
            //}), startFilter);
        }

        function onReorder() {}

        function removeFilter() {
            vm.filter.show = false;
            vm.query.filter = '';

            if (vm.filter.form.$dirty) {
                vm.filter.form.$setPristine();
            }
        }


        function onClickRow(lot) {
            var foundLot = lotList.findLot(lot.block_id, lot.id);
            if(foundLot) gmapServices.triggerEvent(foundLot.polygon, 'click');
        }

        function loadLots() {
            Lots.getList()
                .then(function (result) {
                    console.log('Success fetching lots ', result);
                    $rootScope.lotList = result;
                    filterList();
                }, function (reason) {
                    console.log('Error when fetching lots: ',reason);
                });
        }
        //
        //function startFilter() {
        //    console.log('starting filter');
        //    console.log(vm.search);
        //    //for (var key in vm.searchSolarFilters) {
        //    //    console.log('key: '+key);
        //    //    if (vm.searchSolarFilters.hasOwnProperty(key)) {
        //    //        vm.searchSolarFilters[key] = vm.search;
        //    //    }
        //    //}
        //    //vm.searchSolarFilters.project_name = vm.search;
        //    vm.searchSolarFilters['$'] = vm.search;
        //    filterSolars();
        //}

        //function emptyFilter () {
        //    for (var key in vm.searchSolarFilters) {
        //        if (vm.searchSolarFilters.hasOwnProperty(key)) {
        //            vm.searchSolarFilters[key] = '';
        //        }
        //    }
        //}

        function filterList() {
            if (isEmptyFilter()) {
                $rootScope.lots = $rootScope.lotList;
            } else {
                var filtered = $filter('filter')($rootScope.lotList, vm.searchFilters, false);
                $rootScope.lots = filtered;
            }
        }

        function isEmptyFilter() {
            return vm.query.filter == '';
        }

        function close() {
            $mdDialog.hide();
        }
    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .controller('lotDetailsController', ['$scope', '$mdDialog', 'lot', 'modalServices', lotDetailsController]);

    function lotDetailsController ($scope, $mdDialog, lot, modalServices) {
        var vm = this;

        vm.lot = null;

        vm.initialize = initialize;
        vm.markSold = markSold;
        vm.addOccupant = addOccupant;
        vm.cancel = cancel;

        vm.initialize();

        /* Controller Functions here */

        function initialize () {
            vm.lot = lot;
            console.log('lot details: ', vm.lot);

            //$scope.$watch(function () {
            //    return vm.lot.dimension_height;
            //}, function (newValue, oldValue) {
            //    if (newValue == oldValue) return;
            //    computeLotArea();
            //});
        }

        function markSold () {
            // TODO show modal to select or add new client and a datepicker to select date sold
            // add functionality to update database
            console.log('mark sold lot');

            modalServices.showClientSelection(vm.lot)
                .then(function(success){
                    console.log('ShowClientSelection: ',success);
                    vm.lot.status = 'sold';
                },function(err){
                    console.log('ShowClientSelection: ', err);
                });
        }

        function addOccupant () {
            console.log('add occupant');
            // add functionality to update database
            modalServices.showAddOccupant(vm.lot)
                .then(function (success) {
                    console.log('Show Add Occupant: ', success);
                }, function (err) {
                    console.log('Show Add Occupant: ', err);
                });
        }

        vm.updateLotPricePerSqMtr = updateLotPricePerSqMtr;
        function updateLotPricePerSqMtr (newPrice) {
            console.log('new Price: ',newPrice);
        }

        function cancel () {
            $mdDialog.cancel();
        }

    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .controller('clientSelectionController', ['$rootScope', '$scope', 'LOT_STATUSES', '$mdDialog', 'lot', 'clients', 'Clients', 'Lots', clientSelectionController]);

    function clientSelectionController($rootScope, $scope, LOT_STATUSES, $mdDialog, lot, clients, Clients, Lots) {
        var vm = this;

        vm.lot = null;

        vm.clients = clients;
        vm.client = {};
        vm.selectedClient = null;

        vm.lotParam = {
            status: {
                selected: '',
                showMenu: false,
                data: LOT_STATUSES.splice(0, 2)
            }
        };

        vm.initialize = initialize;
        vm.save = save;
        vm.cancel = cancel;
        vm.clearForm = clearForm;

        vm.initialize();

        /* Controller Functions here */

        function initialize() {
            console.log('lot client select controller initialized');

            // cleared data
            vm.rawClient = angular.copy(vm.client);

            vm.lot = lot;

            console.log('lot details: ', vm.lot);
        }

        function save() {
            console.log('Select Client: ',vm.selectedClient);

            var promise = null;

            if(vm.selectedClient) {
                // update lot with this client id
                vm.lot.client_id = vm.selectedClient.client_id;
                promise = vm.lot.put();
            } else {
                if($scope.newClientForm.$valid) {
                    vm.client.lot_id = vm.lot.id;

                    promise = Clients.post(vm.client);
                }
            }

            promise.then(function (response) {
                console.log('Select Client: ', response);
                $mdDialog.hide();
                // TODO fetch new lot info via http request
                $rootScope.$broadcast('show-lot-detail', {lot: Lots.cast(response.lot)});
            }, function (err) {
                console.log('Error adding new client: ', err);
            });
        }

        function cancel() {
            $mdDialog.cancel();
        }

        function clearForm() {
            console.log('clear form');
            vm.client = angular.copy(vm.rawClient);
            $scope.newClientForm.$setPristine();
        }

    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .controller('indexController', ['sectionList', indexController]);

    function indexController (sectionList) {
        var vm = this;

        vm.showList = false;

        vm.initialize = initialize;
        vm.toggleList = toggleList;

        vm.initialize();

        function initialize () {
            sectionList.loadSections(true);
        }

        function toggleList() {
            vm.showList = !vm.showList;
        }
    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .controller('gmapController', ['$rootScope', 'gmapServices', 'LOT_COLORS', 'NAV_HEIGHT', 'modalServices', gmapController]);

    function gmapController($rootScope, gmapServices, LOT_COLORS, NAV_HEIGHT, modalServices) {

        var vm = this;

        vm.lotColors = LOT_COLORS;

        $rootScope.spinner = {
            active: false
        };

        vm.initialize = initialize;

        vm.initialize();

        function initialize () {
            gmapServices.createMap('map-canvas', NAV_HEIGHT);

            $rootScope.$on('show-lot-detail', function(event, params) {
               var lot = params.lot;

               lot.get()
                   .then(function(response){
                       modalServices.showLotDetail(response)
                           .then(function (response) {

                           }, function (err) {

                           });
                   });

            });
        }
    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .controller('filterController', ['gmapServices', 'alertServices', filterController]);

    function filterController(gmapServices, alertServices) {
        var vm = this;

        vm.filterLayer = '';

        var searchMarker = null;
        var searchInfowindow = null;

        var autocomplete = null;

        vm.initialize = initialize;

        vm.initialize();

        /* Controller Functions here */

        function initialize() {
            autocomplete = gmapServices.initializeAutocomplete('filter-location-input');

            autocomplete.addListener('place_changed', placeChangeCallback);
        }


        //function showResult(data) {
        //    if (!searchInfowindow) searchInfowindow = gmapServices.createInfoWindow('');
        //
        //    if (!searchMarker) {
        //        searchMarker = gmapServices.createCustomMarker(data.coordinates);
        //    } else {
        //        if (!searchMarker.getMap()) gmapServices.showMarker(searchMarker);
        //
        //        searchMarker.setPosition(data.coordinates);
        //    }
        //
        //    searchInfowindow.setContent(data.content);
        //
        //    gmapServices.addListener(searchMarker, 'click', function () {
        //        searchInfowindow.open(gmapServices.map, searchMarker);
        //    });
        //
        //    gmapServices.triggerEvent(searchMarker, 'click');
        //}
        //
        //function hideSearchMarker() {
        //    if (searchMarker && searchMarker.getMap()) {
        //        gmapServices.hideMarker(searchMarker);
        //    }
        //}

        function placeChangeCallback() {
            var place = autocomplete.getPlace();
            if (!place.geometry) {
                alert("Autocomplete's returned place contains no geometry");
                return;
            }
            //console.log('Place Changed!', place);
            // If the place has a geometry, then present it on a map.
            if (place.geometry.viewport) {
                gmapServices.map.fitBounds(place.geometry.viewport);
            } else {
                gmapServices.map.setCenter(place.geometry.location);
                gmapServices.map.setZoom(15);
            }
        }


        /* Non Scope Functions here */

    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .controller('blockDetailsIndexController', ['$rootScope', '$mdSidenav', 'sectionList', 'blockList', 'lotList', 'gmapServices', 'drawingServices', 'modalServices', blockDetailsIndexController]);

    function blockDetailsIndexController ($rootScope, $mdSidenav, sectionList, blockList, lotList, gmapServices, drawingServices, modalServices) {
        var vm = this;

        vm.lastPolygon = null;

        vm.editMode = false;
        vm.tempBlock = {
            name: null,
            polygon: null,
            area: []
        };

        var saveListener = {
            lot: null
        };

        vm.block = {
          id: '',
          name: '',
          lots: [],
          area: []
        };

        vm.blockInfo = {
            lotCount: 0,
            soldLot: 0,
            unsoldLot: 0
        };


        vm.initialize = initialize;
        vm.close = close;
        vm.showBlock = showBlock;

        vm.initialize();

        /* Controller Functions here */

        function initialize () {
            $rootScope.$on('show-block-details', function(event, params){
                console.log('show block details event ', params.block);
                vm.editMode = false;
                vm.block = params.block;
                vm.tempBlock.name = params.block.name;

                updateBlockDetails(vm.block);

                gmapServices.hidePolygon(vm.block.polygon);

                if(vm.lastPolygon) {
                    gmapServices.setEditablePolygon(vm.lastPolygon, false);
                    gmapServices.showPolygon(vm.lastPolygon)
                }

                vm.lastPolygon = vm.block.polygon;

                if(vm.tempBlock.polygon) {
                    gmapServices.hidePolygon(vm.tempBlock.polygon);
                    vm.tempBlock.polygon = null;
                }

                vm.tempBlock.polygon = gmapServices.createCustomPolygon(vm.block.area, blockList.polygonOptions);
            });
        }

        function updateBlockDetails (blk) {
            vm.blockInfo.lotCount += blk.lots.length;
            vm.blockInfo.soldLot += _.where(blk.lots, {status: 'sold'}).length;
            vm.blockInfo.soldLot += _.where(blk.lots, {status: 'occupied'}).length;
            vm.blockInfo.unsoldLot += _.where(blk.lots, {status: 'vacant'}).length;
        }

        /* Section Functions */

        function editSection () {
            toggle(true);
        }

        function saveChanges () {
            toggle(false);
            vm.tempSection.area = drawingServices.getPolygonCoords(vm.tempSection.polygon);

            // to avoid this error "TypeError: Converting circular structure to JSON"
            vm.section.polygon = null;

            vm.section.area = vm.tempSection.area;
            vm.section.name = vm.tempSection.name;

            vm.section.put()
                .then(function(response){
                    gmapServices.hidePolygon(vm.tempSection.polygon);
                    vm.tempSection.polygon = null;
                    vm.lastPolygon = null;

                    vm.section.polygon = gmapServices.createCustomPolygon(vm.section.area, sectionList.polygonOptions);

                }, function(error){
                    console.log('failed updating section: ',error);
                });
        }

        /* End Section Functions */


        /* Block Functions */

        function showBlock(block) {
            gmapServices.setZoomIfGreater(21);
            gmapServices.panToPolygon(block.polygon);
        }

        /* End of Block Functions */

        /* Lot Functions */

        /* End of Lot Functions */


        function toggle(flag) {
            vm.editMode = flag;
            gmapServices.setEditablePolygon(vm.tempSection.polygon, flag);
        }

        vm.openBlockMenu = openBlockMenu;
        var originatorEv;

        function openBlockMenu($mdOpenMenu, ev) {
            originatorEv = ev;
            $mdOpenMenu(ev);
        };

        function close () {
            $mdSidenav('sectionDetailsSidenav')
                .close()
                //.then(function(){
                //    vm.section = {
                //        id: '',
                //        name: '',
                //        area: []
                //    };
                //})
            ;
        }

    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .controller('adminGmapController', ['$rootScope', 'gmapServices', adminGmapController]);

    function adminGmapController($rootScope, gmapServices) {

        var vm = this;

        $rootScope.spinner = {
            active: false
        };

        vm.initialize = initialize;

        vm.initialize();

        function initialize () {
            gmapServices.createMap('admin-map-canvas', 0);
        }

    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .controller('adminController', ['$rootScope', '$scope', 'Sections', 'drawingServices', 'modalServices', 'sectionList', adminController]);

    function adminController ($rootScope, $scope, Sections, drawingServices, modalServices, sectionList) {
        var vm = this;

        // drawing tools
        vm.drawBtn = {
          save: false,
          delete: false,
          cancel: false
        };

        // save listeners
        var saveListeners = {
            section: null
        };

        $rootScope.sections = [];

        vm.initialize = initialize;

        vm.addSection = addSection;

        vm.stopDrawing = stopDrawing;
        vm.saveArea = saveArea;
        vm.deleteSelected = deleteSelected;

        vm.initialize();

        /* Controller Functions here */

        function initialize () {
            sectionList.loadSections();

            $rootScope.$on('start-drawing', function(){
               vm.drawBtn.cancel = true;
            });

            $rootScope.$on('overlay-complete', function () {
                $scope.$apply(function(){
                    vm.drawBtn.save = true;
                    vm.drawBtn.delete = true;
                });
            });
        }

        function addSection (ev) {
            startDrawing();

            saveListeners.section = $scope.$on('save-area', function(event, param){
                modalServices.showAddSection(ev, param.area)
                    .then(function(result){
                        // Restangularized Object
                        Sections.get(result.section.id)
                            .then(function (response) {
                                sectionList.add(response);
                            });
                    }, function(reason){
                        console.log('failed: ',reason);
                    })
                    .finally(function(){
                        saveListeners.section();
                        saveListeners.section = null;
                    });
            });
        }

        function saveArea() {
            if (!drawingServices.overlay) {
                alert('Cannot proceed. No Overlay Drawn.')
                return;
            }

            var area = drawingServices.overlayDataArray;

            $rootScope.$broadcast('save-area', {area: area});

            vm.stopDrawing();
        }

        function deleteSelected() {
            if (drawingServices.overlay) {
                drawingServices.clearOverlay();
                vm.drawBtn.save = false;
            }
        }

        function stopDrawing () {
            drawingServices.stopDrawingMode();

            // hide draw buttons
            for(var key in vm.drawBtn) vm.drawBtn[key] = false;

            // destroy save listeners
            for (var key in saveListeners) {
                if(saveListeners[key]) {
                    saveListeners[key]();
                    saveListeners[key] = null;
                }
            }
        }

        /* Non Scope Functions here */

        function startDrawing () {
            drawingServices.startDrawingMode();
            // Show Cancel Map button
            vm.drawBtn.cancel = true;
        }

    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .controller('addSectionController', ['$mdDialog', 'area', 'Sections', addSectionController]);

    function addSectionController ($mdDialog, area, Sections) {
        var vm = this;

        vm.section = {
            area: area,
            name: ''
        };

        vm.save = save;
        vm.cancel = cancel;

        /* Controller Functions here */

        function save () {
            Sections.post(vm.section)
                .then(function(response){
                    $mdDialog.hide(response);
                }, function(error){
                    console.log('Error: ', error);
                    // Show Errors
                });
        }

        function cancel () {
            $mdDialog.cancel();
        }

    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .controller('addLotOccupantController', ['$rootScope', '$scope', '$mdDialog', 'lot', addLotOccupantController]);

    function addLotOccupantController($rootScope, $scope, $mdDialog, lot) {
        var vm = this;

        vm.lot = null;
        vm.occupant = {};

        vm.initialize = initialize;
        vm.save = save;
        vm.cancel = cancel;
        vm.clearForm = clearForm;

        vm.initialize();

        $scope.maxDate = new Date();

        /* Controller Functions here */

        function initialize() {
            vm.lot = lot;
            console.log('lot details: ', vm.lot);
        }

        function save() {
            if($scope.newForm.$valid) {
                vm.lot.post('deceased', vm.occupant)
                    .then(function (response) {
                        console.log('New Deceased: ', response);
                        $mdDialog.hide();
                        // TODO fetch new lot info via http request
                        $rootScope.$broadcast('show-lot-detail', {lot: vm.lot});
                    }, function (err) {
                        console.log('Error adding new deceased: ', err);
                    });
            }
        }

        function cancel() {
            $mdDialog.cancel();
        }

        function clearForm() {
            vm.occupant = {};
            $scope.newForm.$setPristine();
        }

    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .controller('addLotController', ['$scope', '$mdDialog', 'block', 'area', 'Blocks', 'alertServices', addLotController]);

    function addLotController ($scope, $mdDialog, block, area, Blocks, alertServices) {
        var vm = this;

        vm.block = null;

        vm.lot = {
            block_id: block.id,
            area: area,
            dimension_width: 0,
            dimension_height: 0,
            lot_area: ''
        };

        vm.initialize = initialize;
        vm.save = save;
        vm.cancel = cancel;

        vm.initialize();

        /* Controller Functions here */

        function initialize () {
            // Restangularized
            vm.block = Blocks.cast(block);

            $scope.$watch(function(){
                return vm.lot.dimension_width;
            }, function(newValue, oldValue){
                if (newValue == oldValue) return;
                computeLotArea();
            });

            $scope.$watch(function () {
                return vm.lot.dimension_height;
            }, function (newValue, oldValue) {
                if (newValue == oldValue) return;
                computeLotArea();
            });
        }

        function computeLotArea () {
            vm.lot.lot_area = parseFloat(vm.lot.dimension_width * vm.lot.dimension_height).toFixed(2);
        }

        function save () {
            vm.block.post('lots', vm.lot)
                .then(function(response){
                    $mdDialog.hide(response);
                    alertServices.showLotAdded();
                }, function(error){
                    console.log('Error: ', error);
                    alertServices.showErrorMessage(error.data.message);
                });
        }

        function cancel () {
            $mdDialog.cancel();
        }

    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .controller('addBlockController', ['$mdDialog', 'section', 'area', addBlockController]);

    function addBlockController ($mdDialog, section, area) {
        var vm = this;

        vm.block = {
            area: area,
            name: ''
        };

        vm.save = save;
        vm.cancel = cancel;

        /* Controller Functions here */

        function save () {
            //if (typeof section.addBlock == 'function') {

            section.addBlock(vm.block)
                .then(function(response){
                    $mdDialog.hide(response);
                }, function(error){
                    console.log('Error: ', error);
                });

            //} else {
            //    console.log('function section.addBlock doesnt exist!');
            //}
        }

        function cancel () {
            $mdDialog.cancel();
        }

    }
}());
(function(){
    'use strict';

    var lotStatuses = [
        'vacant',
        'sold',
        'occupied'
    ];

    var lotColorByStatus = {
        vacant: '#2ecc71',
        sold: '#e74c3c',
        occupied: '#9b59b6'
    };

    var lotDimensions = [
        '3 X 3',
        '3 X 4.5',
        '1.5 X 3',
    ];

    angular.module('demoApp')
        .value('LOT_STATUSES', lotStatuses)
        .value('LOT_DIMENSIONS', lotDimensions)
        .value('LOT_COLORS', lotColorByStatus)
    ;

}());


