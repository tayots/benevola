(function () {
    'use strict';

    angular
        .module('demoApp', ['ngMaterial', 'ngMessages', 'ngAnimate', 'restangular', 'oitozero.ngSweetAlert', 'treasure-overlay-spinner'])

        .constant('BASE_URL', window.location.origin)
        .constant('NAV_HEIGHT', 50)

        .config(["$mdThemingProvider", function ($mdThemingProvider) {
            $mdThemingProvider.theme('default')
                .primaryPalette('blue')
                .accentPalette('pink');
        }])

        .config(['RestangularProvider', function (RestangularProvider) {
            //set the base url for api calls on our RESTful services
            RestangularProvider.setBaseUrl(window.location.origin + '/api');
        }]);

}());


(function(){
'use strict';

angular.module('demoApp')
    .factory('webServices', ["webRequest", webServices]);

    function webServices(webRequest) {
        var service = {};

        /*
        * Meters
        */
        //service.getMeters = function (zoomLevel) {
        //    return webRequest.get('/api/meters');
        //};
        //
        //service.getMeterClustersByZoom = function (zoomLevel) {
        //    return webRequest.get('/api/meters/clusters/zoom/' + zoomLevel);
        //};
        //
        //service.getMeterClustersByZoomAndBounds = function (zoomLevel, bounds) {
        //    return webRequest.get('/api/meters/clusters/zoom/' + zoomLevel + '/bounds/' + bounds);
        //};
        //
        //service.getMetersWithinBounds = function (bounds) {
        //    return webRequest.get('/api/meters/bounds/' + bounds);
        //};
        //
        //service.getMetersByID = function (id) {
        //    return webRequest.get('/api/meters/' + id);
        //};
        //
        //service.getMetersBounds = function () {
        //  return webRequest.get('/api/meters/get_bounds');
        //};
        //
        //service.getMeterByMeterNo = function (meterNo) {
        //    return webRequest.get('/api/meters/get_by_meter_no/' + meterNo);
        //}

        return service;
    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .factory('sectionList', ['$rootScope', 'gmapServices', 'Sections', '$mdSidenav', sectionList]);

    function sectionList ($rootScope, gmapServices, Sections, $mdSidenav) {
        var service = {};

        service.polygoncolor = '#3498db';
        service.polygonOptions = {
            clickable: true,
            fillColor: service.polygoncolor,
            fillOpacity: 0,
            strokeColor: service.polygoncolor,
            strokeOpacity: 0.9,
            strokeWeight: 4,
            zIndex: 100
        };

        service.sections = [];

        service.loadSections = loadSections;
        service.add = add;

        function loadSections () {
            Sections.getList()
                .then(function(response){
                    response.forEach(function(section){
                        service.add(section);
                    });
                }, function(error){
                    console.log('Error loading sections list: ',error);
                });
        }

        function add (sectionData) {
            //var section = {
            //    id: sectionData.id,
            //    name: sectionData.name,
            //    area: sectionData.area
            //};
            //section.polygon = createPolygon(sectionData);
            sectionData.polygon = createPolygon(sectionData);
            service.sections.push(sectionData);
            return sectionData;
        }

        function createPolygon(section) {
            var polygon = gmapServices.createCustomPolygon(section.area, service.polygonOptions);

            gmapServices.addListener(polygon, 'click', function() {
                section.get()
                    .then(function(sectionResponseObject){
                        console.log('sectionResponseObject: ', sectionResponseObject);
                        $mdSidenav('sectionDetailsSidenav')
                            .open()
                            .then(function () {
                                $rootScope.$broadcast('show-section-details', {section: sectionResponseObject});
                                gmapServices.panToPolygon(polygon);
                            });
                    });

            });

            return polygon;
        }

        return service;
    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .factory('modalServices', ['$mdDialog', '$mdMedia', '$rootScope', '$q', modalServices]);

    function modalServices ($mdDialog, $mdMedia, $rootScope, $q) {
        var service = {};

        service.customFullscreen = $mdMedia('sm') || $mdMedia('xs');

        service.addSectionModal = null;
        service.addBlockModal = null;

        service.showAddSection = showAddSection;
        service.showAddBlock = showAddBlock;

        function showAddSection (event, sectionArea) {
            var dfd = $q.defer();

            if(service.addSectionModal) {
                dfd.reject('Modal already opened');
            } else {
                $rootScope.$broadcast("modal-opened");

                service.addSectionModal = $mdDialog.show({
                    controller: 'addSectionController',
                    controllerAs: 'addSectionCtl',
                    templateUrl: 'partials/modals/add_section_dialog.tmpl.html',
                    parent: angular.element(document.body),
                    locals: {area: sectionArea},
                    targetEvent: event,
                    fullscreen: service.customFullscreen
                });

                service.addSectionModal.then(
                   function(result) {
                    service.addSectionModal = null;
                    dfd.resolve(result);
                }, function (reason) {
                    $rootScope.$broadcast('modal-dismissed');
                    service.addSectionModal = null;
                    dfd.reject(reason);
                });
            }
            return dfd.promise;
        }

        function showAddBlock(event, section, sectionArea) {
            var dfd = $q.defer();

            if (service.addBlockModal) {
                dfd.reject('Modal already opened');
            } else {
                $rootScope.$broadcast("modal-opened");

                service.addBlockModal = $mdDialog.show({
                    controller: 'addBlockController',
                    controllerAs: 'addBlockCtl',
                    templateUrl: 'partials/modals/add_block_dialog.tmpl.html',
                    parent: angular.element(document.body),
                    locals: {section: section, area: sectionArea},
                    targetEvent: event,
                    fullscreen: service.customFullscreen
                });

                service.addBlockModal.then(
                    function (result) {
                        service.addBlockModal = null;
                        dfd.resolve(result);
                    }, function (reason) {
                        $rootScope.$broadcast('modal-dismissed');
                        service.addBlockModal = null;
                        dfd.reject(reason);
                    });
            }
            return dfd.promise;
        }

        return service;
    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .factory('loaderServices', ['$rootScope', loaderServices]);

    function loaderServices ($rootScope) {
        var service = {};

        service.showLoader = showLoader;
        service.hideLoader = hideLoader;

        function showLoader () {
            $rootScope.spinner.active = true;
        }

        function hideLoader (_doApply) {
            var doApply = _doApply || false;
            if(doApply) {
                $rootScope.$apply(function () {
                    $rootScope.spinner.active = false;
                });
            } else {
                $rootScope.spinner.active = false;
            }
        }
        

        return service;
    }
}());
(function(){
    'use strict';

    angular.module('demoApp')
        .factory('gmapServices', ['$log', '$q', gmapServices]);

    function gmapServices($log, $q) {
        var service = {};

        //infowindow balloons
        service.INFO_WINDOWS = [];

        service.ZOOM_OUT_LEVEL = 8;
        service.ZOOM_IN_LEVEL = 19;

        service.map = null;
        service.mapProjection = null;
        service.overlayView = null;

        service.geocoder = null;

        service.markers = [];

        service.defaultZoom = service.ZOOM_IN_LEVEL;

        service.centerLatLng = new google.maps.LatLng(10.382237, 123.955110);

        // Cluster Objects
        // for Different Layers
        service.markerClusterers = {};

        // Maintain only one infobox
        // Prevent from opening multiple infoboxes
        service.lastInfoboxOpen = null;
        service.infoboxes = [];

        /**
         * Service Functions
         */
        service.apiAvailable = apiAvailable;
        service.createMap = createMap;
        service.createInfoBox = createInfoBox;
        service.openInfoBox = openInfoBox;
        service.closeInfoBox = closeInfoBox;
        service.closeAllInfoBox = closeAllInfoBox;
        service.setMapCursorCrosshair = setMapCursorCrosshair;
        service.setMapBounds = setMapBounds;
        service.getBoundsFromPath = getBoundsFromPath;
        service.setMapCursorDefault = setMapCursorDefault;
        service.addMapListener = addMapListener;
        service.getDistanceOfPath = getDistanceOfPath;
        service.fromLatLngToContainerPixel = fromLatLngToContainerPixel;
        service.fromLatLngToDivPixel = fromLatLngToDivPixel;
        service.fromLatLngToPoint = fromLatLngToPoint;
        service.createCoordinate = createCoordinate;
        service.createInfoWindow = createInfoWindow;
        service.createCanvasInfoWindow = createCanvasInfoWindow;
        service.hideCanvasInfoWindow = hideCanvasInfoWindow;
        service.showInfoWindow = showInfoWindow;
        service.hideInfoWindow = hideInfoWindow;
        service.clearInstanceListeners = clearInstanceListeners;
        service.initMarker = initMarker;
        service.createMarker = createMarker;
        service.createCustomMarker = createCustomMarker;
        service.createCircleMarker = createCircleMarker;
        service.panTo = panTo;
        service.panToOffsetLeft = panToOffsetLeft;
        service.showMarker = showMarker;
        service.showMarkers = showMarkers;
        service.hideMarker = hideMarker;
        service.hideMarkers = hideMarkers;
        service.destroyMarker = destroyMarker;
        service.destroyPolyline = destroyPolyline;
        service.centerMarker = centerMarker;
        service.setMapCenter = setMapCenter;
        service.setMapCenterDefault = setMapCenterDefault;
        service.setZoom = setZoom;
        service.setZoomIfGreater = setZoomIfGreater;
        service.setZoomDefault = setZoomDefault;
        service.setZoomInDefault = setZoomInDefault;
        service.createDrawingManager = createDrawingManager;
        service.createDrawingToolsManager = createDrawingToolsManager;
        service.showDrawingManager = showDrawingManager;
        service.hideDrawingManager = hideDrawingManager;
        service.setEnableDrawingManager = setEnableDrawingManager;
        service.createCircle = createCircle;
        service.updateCircle = updateCircle;
        service.initPolygon = initPolygon;
        service.createPolygon = createPolygon;
        service.createCustomPolygon = createCustomPolygon;
        service.updatePolygon = updatePolygon;
        service.showPolygon = showPolygon;
        service.hidePolygon = hidePolygon;
        service.resetPolygonFill = resetPolygonFill;
        service.fillPolygon = fillPolygon;
        service.panToPolygon = panToPolygon;
        service.setEditablePolygon = setEditablePolygon;
        service.createPolyline = createPolyline;
        service.createDashedPolyline = createDashedPolyline;
        service.updatePolyline = updatePolyline;
        service.showPolyline = showPolyline;
        service.hidePolyline = hidePolyline;
        service.addListener = addListener;
        service.addListenerOnce = addListenerOnce;
        service.clearInstanceListeners = clearInstanceListeners;
        service.clearListeners = clearListeners;
        service.removeListener = removeListener;
        service.trigger = trigger;
        service.showCurrentLocation = showCurrentLocation;
        service.reverseGeocode = reverseGeocode;
        service.loadKMLByURL = loadKMLByURL;
        service.initMapClusterer = initMapClusterer;
        service.destroyMapClusterer = destroyMapClusterer;
        service.createClusterMarker = createClusterMarker;
        service.getClustererInstance = getClustererInstance;
        service.clearClusterMarkers = clearClusterMarkers;
        service.resetClusters = resetClusters;
        service.insertImageMapType = insertImageMapType;
        service.removeOverlayAtIndex = removeOverlayAtIndex;
        service.initializeAutocomplete = initializeAutocomplete;
        service.containsLocation = containsLocation;
        service.triggerEvent = triggerEvent;

        function apiAvailable() {
            return typeof window.google === 'object';
        }

        function createMap(mapId, navHeight) {
            var _navHeight = navHeight || 0;

            var mapIdLoc = mapId || 'map3d';
            var myMapId = '#' + mapIdLoc;

            if (service.map) return service.map;
            if (!service.apiAvailable()) return null;

            var mapOptions = {
                zoom: service.defaultZoom,
                minZoom: 2,
                center: service.centerLatLng,
                mapTypeControl: false,
                mapTypeId: google.maps.MapTypeId.HYBRID,
                zoomControlOptions: {
                    position: google.maps.ControlPosition.RIGHT_BOTTOM
                },
                panControl: false
            };

            $(myMapId).height($(window).height() - (_navHeight));

            service.map = new google.maps.Map(document.getElementById(mapIdLoc), mapOptions);

            // handle window resize event
            google.maps.event.addDomListener(window, 'resize', function () {
                $(myMapId).height($(window).height() - (_navHeight));
                var center = service.map.getCenter();
                google.maps.event.trigger(service.map, 'resize');
                service.map.setCenter(center);
            });

            return service.map;
        }

        function createInfoBox(template) {
            return new InfoBox({
                content: template || '',
                disableAutoPan: true,
                maxWidth: 0,
                pixelOffset: new google.maps.Size(25, -115),
                //closeBoxMargin: '15px 5px',
                closeBoxURL: 'static/resources/images/close-icon.png',
                isHidden: false,
                pane: 'floatPane',
                enableEventPropagation: true
            });
        }

        function openInfoBox(infobox, marker) {
            if( !(service.map && infobox && marker)) return;

            // Close last infobox open
            if (service.lastInfoboxOpen) service.lastInfoboxOpen.close();

            infobox.open(service.map, marker);

            service.lastInfoboxOpen = infobox;
            service.infoboxes.push(infobox);
        }

        function closeAllInfoBox() {
            service.infoboxes.forEach(function(infobox, index) {
               if(infobox) {
                   infobox.close();
               }
            });
        }

        function closeInfoBox() {
            if (service.lastInfoboxOpen) service.lastInfoboxOpen.close();
        }

        function addMapListener(eventName, callback) {
            if (service.map) {
                return service.addListener(service.map, eventName, callback);
            }
            return null;
        }

        function setMapCursorDefault() {
            if (service.map) service.map.setOptions({draggableCursor: null});
        }

        function setMapCursorCrosshair() {
            if (service.map) service.map.setOptions({draggableCursor: 'crosshair'});
        }

        function setMapBounds(bounds) {
            if (service.map) service.map.fitBounds(bounds);
        }

        function getBoundsFromPath(path) {
            if (!service.apiAvailable()) return null;
            var bounds = new google.maps.LatLngBounds();
            for (var index = 0; index < path.length; index++) {
                var point = path[index];
                bounds.extend(point);
            }
            return bounds;
        }

        function getDistanceOfPath(path) {
            if (!service.apiAvailable()) return 0;
            return google.maps.geometry.spherical.computeLength(path);
        }

        function fromLatLngToContainerPixel(latlng) {
            if (service.overlayView) {
                return service.overlayView.getProjection().fromLatLngToContainerPixel(latlng);
            }
            return new google.maps.Point();
        }

        function fromLatLngToDivPixel(latlng) {
            if (service.overlayView) {
                return service.overlayView.getProjection().fromLatLngToDivPixel(latlng);
            }
            return new google.maps.Point();
        }

        function fromLatLngToPoint(latlng) {
            if (service.map) {
                var numTiles = 1 << service.map.getZoom();
                var projection = new MercatorProjection();
                var worldCoordinate = projection.fromLatLngToPoint(latlng);
                return new google.maps.Point(
                    worldCoordinate.x * numTiles,
                    worldCoordinate.y * numTiles
                );
            } else {
                return new google.maps.Point();
            }
        }

        function createCoordinate(latitude, longitude) {
            return new google.maps.LatLng(latitude, longitude);
        }

        function createInfoWindow(content) {
            if (!service.apiAvailable()) return null;
            return new google.maps.InfoWindow({content: content});
        }

        function createCanvasInfoWindow() {
            if (!service.apiAvailable()) return null;

            return new CanvasInfoWindow(service.map);
        }

        function hideCanvasInfoWindow(infoWindow) {
            if (infoWindow) infoWindow.hideInfowindow();
        };

        function showInfoWindow(infoWindow, target) {
            if (infoWindow) infoWindow.open(service.map, target);
        }

        function hideInfoWindow(infoWindow) {
            if (infoWindow) infoWindow.close();
        }

        function clearInstanceListeners(_instance) {
            google.maps.event.clearInstanceListeners(_instance);
        }

        function initMarker(_position, _icon, _opts) {
            if (!service.apiAvailable()) return null;

            var additionalOpts = _opts || {};

            var opts = angular.extend({}, {
                position: _position,
                map: service.map,
                icon: _icon
            }, additionalOpts);

            return new google.maps.Marker(opts);
        }

        function createMarker(_position, _color) {
            _color = _color || service.MARKER_ICONS.RED;
            var marker = service.initMarker(_position, _color);

            service.markers.push(marker);

            return marker;
        }

        function createCustomMarker(_position, _icon, _opts) {
            var opts = _opts || {},
                icon = _icon || 'images/markers/default-marker.png';

            return service.initMarker(_position, icon, opts);
        }

        function createCircleMarker(_position, color) {
            var icon = {
                path: google.maps.SymbolPath.CIRCLE,
                scale: 5,
                fillColor: color || '#6ac1ff',
                fillOpacity: 1,
                strokeColor: 'black',
                strokeWeight: 1
            };

            var marker = service.initMarker(_position, icon);
            service.markers.push(marker);

            return marker;
        }

        function panTo(_position) {
            if (!service.map) return;

            service.map.panTo(_position);
        }

        function panToOffsetLeft(_position, _offset) {
            var offset = _offset || 0.013;
            var latLng = {};

            if(_position instanceof google.maps.LatLng) {
                console.log('object latlng');
                latLng.lat = _position.lat();
                latLng.lng = _position.lng() + offset;
            } else{
                latLng = _position;
                latLng.lng += offset;
            }

            this.panTo(latLng);
        }

        function showMarker(marker) {
            if (marker && marker instanceof google.maps.Marker) marker.setMap(service.map);
        }

        function showMarkers(markerArray) {
            markerArray.forEach(function (marker) {
                service.showMarker(marker);
            });
        }

        function hideMarker(marker) {
            if (marker && marker instanceof google.maps.Marker) marker.setMap(null);
        }

        function hideMarkers(markerArray) {
            markerArray.forEach( function(marker) {
                service.hideMarker(marker);
            });
        }

        function destroyPolyline(polyline) {
            if (polyline && polyline instanceof google.maps.Polyline) polyline.setMap(null);
            service.clearInstanceListeners(polyline);
            polyline = null;
        }

        function destroyMarker(marker) {
            if (marker instanceof Cluster) {
                marker.remove();
            }
            else if (marker instanceof google.maps.Marker) {
                service.hideMarker(marker);
                service.clearInstanceListeners(marker);
            }
            marker = null;
        }

        function centerMarker(marker) {
            if (service.map) {
                service.map.setCenter(marker.position);
            }
        }

        function setMapCenter(coordinates) {
            if (service.map) {
                service.map.setCenter(coordinates);
            }
        }

        function setMapCenterDefault() {
            service.setMapCenter(service.centerLatLng);
        }

        function setZoom(zoomValue) {
            if (service.map) {
                service.map.setZoom(zoomValue);
            }
        }

        function setZoomIfGreater(zoomValue) {
            if (zoomValue > service.map.getZoom())
                service.setZoom(zoomValue);
        }

        function setZoomDefault() {
            service.setZoom(service.defaultZoom);
        }

        function setZoomInDefault() {
            service.setZoom(service.ZOOM_IN_LEVEL);
        }

        function createDrawingManager(_color) {
            if (!service.apiAvailable()) return null;

            var strokeColor = _color || '#0000ff';

            var drawingManager = new google.maps.drawing.DrawingManager({
                drawingMode: null,
                drawingControl: true,
                drawingControlOptions: {
                    position: google.maps.ControlPosition.TOP_CENTER,
                    drawingModes: [
                        google.maps.drawing.OverlayType.POLYGON,
                        google.maps.drawing.OverlayType.RECTANGLE
                    ]
                },
                polygonOptions: {
                    clickable: true,
                    draggable: true,
                    editable: true,
                    geodesic: true,
                    fillColor: '#ffffff',
                    fillOpacity: 0,
                    strokeColor: strokeColor,
                    strokeOpacity: 0.9,
                    strokeWeight: 2,
                    zIndex: 1
                },
                rectangleOptions: {
                    clickable: true,
                    draggable: true,
                    editable: true,
                    fillColor: '#ffffff',
                    fillOpacity: 0,
                    strokeColor: strokeColor,
                    strokeOpacity: 0.9,
                    strokeWeight: 2,
                    zIndex: 1
                }
            });
            service.drawingManager = drawingManager;
            return drawingManager;
        }

        function createDrawingToolsManager() {
            if (!service.apiAvailable()) return null;
            var drawingManager = new google.maps.drawing.DrawingManager({
                drawingMode: null,
                drawingControl: true,
                drawingControlOptions: {
                    position: google.maps.ControlPosition.TOP_CENTER,
                    drawingModes: [
                        google.maps.drawing.OverlayType.MARKER,
                        google.maps.drawing.OverlayType.CIRCLE,
                        google.maps.drawing.OverlayType.POLYGON,
                        google.maps.drawing.OverlayType.POLYLINE,
                        google.maps.drawing.OverlayType.RECTANGLE
                    ]
                },
                markerOptions: {
                    icon: service.MARKER_ICONS.RED
                },
                circleOptions: {
                    clickable: true,
                    draggable: false,
                    editable: false,
                    fillColor: '#0000ff',
                    fillOpacity: 0.2,
                    strokeColor: '#0000ff',
                    strokeOpacity: 0.8,
                    strokeWeight: 1,
                    zIndex: 1
                },
                polygonOptions: {
                    clickable: true,
                    draggable: false,
                    editable: false,
                    geodesic: true,
                    fillColor: '#0000ff',
                    fillOpacity: 0.2,
                    strokeColor: '#0000ff',
                    strokeOpacity: 0.8,
                    strokeWeight: 1,
                    zIndex: 1
                },
                polylineOptions: {
                    clickable: true,
                    draggable: false,
                    editable: false,
                    strokeColor: '#0000ff',
                    strokeOpacity: 0.8,
                    strokeWeight: 1,
                    zIndex: 1
                },
                rectangleOptions: {
                    clickable: true,
                    draggable: false,
                    editable: false,
                    fillColor: '#0000ff',
                    fillOpacity: 0.2,
                    strokeColor: '#0000ff',
                    strokeOpacity: 0.8,
                    strokeWeight: 1,
                    zIndex: 1
                }
            });
            service.drawingManager = drawingManager;
            return drawingManager;
        }

        function showDrawingManager(drawingManager) {
            if (drawingManager) {
                if(!drawingManager.getMap()) {
                    drawingManager.setMap(service.map);
                }
                service.setEnableDrawingManager(drawingManager, true);
            }
        }

        function hideDrawingManager(drawingManager) {
            if (drawingManager) {
                drawingManager.setMap(null);
                service.setEnableDrawingManager(drawingManager, false);
            }
        }

        function setEnableDrawingManager(drawingManager, enabled) {
            if (drawingManager) {
                var drawingOptions = {drawingControl: enabled};
                // if drawing mode is disabled, set current mode to hand pointer.
                if (!enabled) drawingOptions['drawingMode'] = null;
                drawingManager.setOptions(drawingOptions);
            }
        }

        function createCircle(latitude, longitude, radius) {
            if (!service.apiAvailable()) return null;
            var latlng = new google.maps.LatLng(latitude, longitude);
            var circleOptions = {
                center: latlng,
                clickable: false,
                draggable: false,
                editable: false,
                fillColor: '#ffffff',
                fillOpacity: 0,
                map: service.map,
                radius: radius,
                strokeColor: '#0000ff',
                strokeOpacity: 0.9,
                strokeWeight: 2,
                zIndex: 100
            };
            return new google.maps.Circle(circleOptions);
        }

        function updateCircle(circle, latitude, longitude, radius) {
            if (circle) {
                circle.setCenter({lat: latitude, lng: longitude});
                circle.setRadius(radius);
            }
        }

        function initPolygon(path, color) {
            if (!service.apiAvailable()) return null;

            var defaultColor = color || '#0000ff';
            var polygonOptions = {
                path: path,
                clickable: false,
                draggable: false,
                editable: false,
                fillColor: defaultColor,
                fillOpacity: 0,
                strokeColor: defaultColor,
                strokeOpacity: 0.9,
                strokeWeight: 2,
                zIndex: 100
            };

            return new google.maps.Polygon(polygonOptions);
        }

        function createCustomPolygon(path, opts) {
            var _opts = {
                path: path,
                map: service.map
            };
            angular.merge(_opts, opts);
            return new google.maps.Polygon(_opts);
        }

        function createPolygon(path, color) {
            var polygon = service.initPolygon(path, color);

            polygon.setMap(service.map);

            return polygon;
        }

        function updatePolygon(polygon, path) {
            if (polygon) polygon.setPath(path);
        }

        function showPolygon(polygon) {
            if (polygon) polygon.setMap(service.map);
        }

        function hidePolygon(polygon) {
            if (polygon) polygon.setMap(null);
        }

        function resetPolygonFill(polygon) {
            polygon.setOptions({
                fillOpacity: 0
            });
        }

        function fillPolygon(polygon) {
            polygon.setOptions({
                fillOpacity: 0.5
            });
        }

        function panToPolygon(polygon) {
            if (!service.map || !polygon) return;

            var bounds = new google.maps.LatLngBounds();

            polygon.getPath().forEach( function(path){
                bounds.extend(path);
            });

            service.panTo(bounds.getCenter());
        }

        function setEditablePolygon (polygon, flag) {
            var isEditable = flag !== false;

            polygon.setOptions({editable: isEditable, draggable: isEditable});
        }

        function createPolyline(path, lineColor) {
            if (!service.apiAvailable()) return null;
            var polylineOptions = {
                path: path,
                clickable: true,
                draggable: false,
                editable: false,
                map: service.map,
                strokeColor: lineColor || '#ff0000',
                strokeOpacity: 1,
                strokeWeight: 2,
                zIndex: 100
            };
            return new google.maps.Polyline(polylineOptions);
        }

        function createDashedPolyline(path, lineColor) {
            if (!service.apiAvailable()) return null;

            var lineSymbol = {
                path: 'M 0,-1 0,1',
                strokeOpacity: 1,
                scale: 1
            };

            var polylineOptions = {
                path: path,
                clickable: true,
                draggable: false,
                editable: false,
                map: service.map,
                strokeColor: lineColor || '#ff0000',
                icons: [{
                    icon: lineSymbol,
                    offset: '0',
                    repeat: '3px'
                }],
                strokeOpacity: 0,
                zIndex: 100
            };
            return new google.maps.Polyline(polylineOptions);
        }

        function updatePolyline(polyline, path) {
            if (polyline) polyline.setPath(path);
        }

        function showPolyline(polyline) {
            if (polyline) polyline.setMap(service.map);
        }

        function hidePolyline(polyline) {
            if (polyline) polyline.setMap(null);
        }

        function addListener(instance, eventName, handler) {
            if (!service.apiAvailable()) return null;
            return google.maps.event.addListener(instance, eventName, handler);
        }

        function addListenerOnce(instance, eventName, handler, capture) {
            if (!service.apiAvailable()) return null;
            return google.maps.event.addListenerOnce(instance, eventName, handler, capture);
        }

        function clearInstanceListeners(instance) {
            if (service.apiAvailable())
                google.maps.event.clearInstanceListeners(instance);
        }

        function clearListeners(instance, eventName) {
            if (service.apiAvailable())
                google.maps.event.clearListeners(instance, eventName);
        }

        function removeListener(listener) {
            if (service.apiAvailable())
                google.maps.event.removeListener(listener);
        }

        function trigger(instance, eventName, args) {
            if (service.apiAvailable())
                google.maps.event.trigger(instance, eventName, args);
        }

        function showCurrentLocation(_latLng, _isDraggable) {
            var icon = '/images/markers/current-location.png';
            var isDraggable = _isDraggable || false;

            return service.createCustomMarker(_latLng, icon, {draggable: isDraggable});
        }

        function reverseGeocode(latLng) {
            if (!service.geocoder) return;

            var dfd = $q.defer();

            service.geocoder.geocode({'latLng': latLng}, function (results, status) {
                if (status == google.maps.GeocoderStatus.OK) {
                    dfd.resolve(results);
                } else {
                    var error = "Geocoder failed due to: " + status;
                    $log.error(error);
                    dfd.reject(error);
                }
            });

            return dfd.promise;
        }

        function loadKMLByURL(srcUrl, kmlOptions) {
            if (service.map) {
                var opt = {
                    url: srcUrl,
                    map: service.map,
                    preserveViewport: true
                };

                if (kmlOptions) {
                    opt = angular.extend({}, opt, kmlOptions);
                }

                return new google.maps.KmlLayer(opt);
            }
            return null;
        }

        function loadClusterStyles(layerName) {
            var defaultStyle = 'resources/images/cluster_icons/m';

            if(layerName == 'meters') {
                return defaultStyle;
            } else if(layerName == 'transformers') {
                return 'resources/images/cluster_icons/transformers/m';
            } else if(layerName == 'poles') {
                return 'resources/images/cluster_icons/poles/m';
            }
            return defaultStyle;
        }

        function initMapClusterer(layerName) {
            if (!service.markerClusterers[layerName]) {
                var clusterStyle = loadClusterStyles(layerName);

                service.markerClusterers[layerName] = new MarkerClusterer(service.map, [],
                    {imagePath: clusterStyle});

                return service.markerClusterers[layerName];
            }
            return null;
        }

        function destroyMapClusterer(layerName) {
            if (service.markerClusterers[layerName]) {
                service.markerClusterers[layerName] = null;
            }
        }

        function createClusterMarker(_position, clusterCount, layerName) {
            if (!service.apiAvailable() || !service.markerClusterers[layerName]) return null;

            var latLngObj = new google.maps.LatLng(_position.lat, _position.lng)
            var cluster = new Cluster(service.markerClusterers[layerName]);

            cluster.center_ = latLngObj;

            cluster.clusterIcon_.setCenter(latLngObj);
            cluster.clusterIcon_.setSums({text: clusterCount, index: Math.round(Math.log(clusterCount) / Math.LN10)});
            cluster.clusterIcon_.textColor_ = 'white';
            cluster.clusterIcon_.show();
            cluster.clusterIcon_.triggerClusterClick = function () {
                var currentZoom = service.map.getZoom();
                service.map.setZoom(++currentZoom);
                service.map.setCenter(cluster.center_);
            };

            return cluster;
        }

        function getClustererInstance(layerName) {
            return service.markerClusterers[layerName];
        }

        function clearClusterMarkers(clusterArray) {
            clusterArray.forEach(function (item, index) {
                if (item instanceof Cluster) {
                    item.remove();
                }
                clusterArray[index] = null;
            });
        }

        function resetClusters(layerName) {
            if (service.markerClusterers[layerName]) {
                service.markerClusterers[layerName].clusters_ = [];
            }
        }

        function insertImageMapType(srcUrl, insertIndex) {
            if (!service.apiAvailable()) return;

            var _insertIndex = insertIndex || 0;

            var imageTile = new google.maps.ImageMapType({
                getTileUrl: function (coord, zoom) {
                    var z2 = Math.pow(2, zoom);
                    var y = coord.y,
                        x = coord.x >= 0 ? coord.x : z2 + coord.x

                    return srcUrl + '/' + zoom + "/" + x + "/" + y + ".png";
                },
                tileSize: new google.maps.Size(256, 256),
                isPng: true,
                opacity: 1.0
            });

            service.map.overlayMapTypes.insertAt(_insertIndex, imageTile);

            return _insertIndex;
        }

        function removeOverlayAtIndex(index) {
            service.map.overlayMapTypes.setAt(index, null);
        }

        function initializeAutocomplete(elementId) {
            var input = document.getElementById(elementId);
            var autocomplete = new google.maps.places.Autocomplete(input, {
                types: ["geocode"]
            });

            autocomplete.bindTo('bounds', service.map);

            return autocomplete;
        }

        function containsLocation (latLng, polygon) {
            if(!polygon) return;

            return google.maps.geometry.poly.containsLocation(latLng, polygon);
        }

        function triggerEvent (obj, event) {
            google.maps.event.trigger(obj, 'click');
        }

        return service;
    }
}());


(function () {
    'use strict';

    angular.module('demoApp')
        .factory('drawingServices', ['gmapServices', '$rootScope', drawingServices]);

    function drawingServices(gmapServices, $rootScope) {

        var service = {};
        service.drawingManager = null;
        service.drawingCompleteListener = null;

        service.overlay = null;
        service.overlayType = '';
        service.overlayDataArray = [];

        service.strokeColor = '';

        /**
         * Functions
         */
        service.initDrawingManager = initDrawingManager;
        service.initDrawingListener = initDrawingListener;
        service.setPanControl = setPanControl;
        service.hideDrawingManager = hideDrawingManager;
        service.startDrawingMode = startDrawingMode;
        service.setListenerOfType = setListenerOfType;
        service.stopDrawingMode = stopDrawingMode;
        service.hideOverlay = hideOverlay;
        service.clearOverlay = clearOverlay;
        service.getAreaCoords = getAreaCoords;
        service.getAreaFormData = getAreaFormData;
        service.getPolygonCoords = getPolygonCoords;
        service.getRectangleCorners = getRectangleCorners;
        service.getRectangleCoords = getRectangleCoords;


        function initDrawingManager() {
            if (service.drawingManager) {
                // Reinitialize Drawing Listener
                service.initDrawingListener();
                return;
            }

            service.drawingManager = gmapServices.createDrawingManager(service.overlayStrokeColor);
            service.initDrawingListener();
        }


        function initDrawingListener() {
            if (!service.drawingManager) return;

            if (service.drawingCompleteListener) return;

            service.drawingCompleteListener = gmapServices.addListener(
                service.drawingManager, 'overlaycomplete', overlayCompleteListener);
        }


        function overlayCompleteListener(eventArgs) {
            // Set only one overlay
            if (service.overlay) {
                service.overlay.setMap(null);
                service.overlay = null;
                service.overlayDataArray = [];
            }

            service.overlay = eventArgs.overlay;
            service.overlay.setMap(gmapServices.map);

            service.overlayType = eventArgs.type;
            service.overlayDataArray = service.getAreaCoords();

            // Add Listener when overlay is resized
            service.setListenerOfType(eventArgs, function (args) {
                service.overlay = args.overlay;
                service.overlayType = args.type;
                service.overlayDataArray = service.getAreaCoords();
            });

            // Set control to pan every after drawing
            service.setPanControl();

            $rootScope.$broadcast('overlay-complete');
        }


        function setPanControl() {
            service.drawingManager.setDrawingMode(null);
        }


        function hideDrawingManager() {
            if (service.drawingManager) {
                gmapServices.hideDrawingManager(service.drawingManager);
            }
        }

        function startDrawingMode(strokeColor) {
            if(strokeColor) service.overlayStrokeColor = strokeColor;

            service.initDrawingManager();

            gmapServices.showDrawingManager(service.drawingManager);
        }

        function setListenerOfType(eArgs, callbackFn) {
            switch (eArgs.type) {
                // Add Listener Events For Rectangle Changed
                case google.maps.drawing.OverlayType.RECTANGLE:
                    google.maps.event.addListener(eArgs.overlay, 'bounds_changed', function () {
                        callbackFn(eArgs);
                    });
                    break;
                // Add Listener Events For Polygon Changed
                case google.maps.drawing.OverlayType.POLYGON:
                    google.maps.event.addListener(eArgs.overlay.getPath(), 'set_at', function () {
                        callbackFn(eArgs);
                    });
                    google.maps.event.addListener(eArgs.overlay.getPath(), 'insert_at', function (e) {
                        callbackFn(eArgs);
                    });
            }
        }

        function stopDrawingMode() {
            if (service.drawingCompleteListener) {
                gmapServices.removeListener(service.drawingCompleteListener);
                service.drawingCompleteListener = null;
            }

            service.hideDrawingManager();

            service.hideOverlay();
        }

        function cancelDrawingMode() {
            service.stopDrawingMode();
        }

        function hideOverlay() {
            if (!service.overlay) return;

            service.overlay.setMap(null);
            service.overlay = null;
        }

        function clearOverlay() {
            hideOverlay();

            service.overlayDataArray = [];
            service.overlayType = '';
        }

        function getAreaCoords() {
            if (service.overlayType == google.maps.drawing.OverlayType.POLYGON) {
                return service.getPolygonCoords();
            }
            else if (service.overlayType == google.maps.drawing.OverlayType.RECTANGLE) {
                return service.getRectangleCorners();
            }

            return [];
        }

        function getPolygonCoords(_polygon) {
            var polygon = _polygon || service.overlay;

            if (!polygon) return;

            var path = polygon.getPath().getArray();
            var data = [];

            for (var index in path) {
                data.push({
                    lat: path[index].lat(),
                    lng: path[index].lng()
                });
            }

            return data;
        }

        function getAreaFormData(_area) {
            return getPolygonCoords(_area);
        }

        function getRectangleCorners(_rect) {
            var rect = _rect || service.overlay;

            if (!rect) return;

            var bounds = rect.getBounds();
            var min = bounds.getNorthEast();
            var max = bounds.getSouthWest();
            var data = [];

            data.push({lat: min.lat(), lng: min.lng()});
            data.push({lat: max.lat(), lng: min.lng()});
            data.push({lat: max.lat(), lng: max.lng()});
            data.push({lat: min.lat(), lng: max.lng()});

            return data;
        }

        function getRectangleCoords() {
            if (!service.overlay) return;

            var bounds = service.overlay.getBounds();
            var min = bounds.getNorthEast(),
                max = bounds.getSouthWest();
            var data = [];

            data.push({lat: min.lat(), lng: min.lng()});
            data.push({lat: max.lat(), lng: max.lng()});

            return data;
        }

        return service;
    }

}());

(function(){
'use strict';

angular.module('demoApp')
    .factory('blockList', ['$rootScope', 'gmapServices', 'Blocks', '$mdSidenav', blockList]);

    function blockList ($rootScope, gmapServices, Blocks, $mdSidenav) {
        var service = {};

        service.polygoncolor = '#e74c3c';
        service.polygonOptions = {
            clickable: true,
            fillColor: service.polygoncolor,
            fillOpacity: 0,
            strokeColor: service.polygoncolor,
            strokeOpacity: 0.9,
            strokeWeight: 2,
            zIndex: 101
        };

        service.blocks = [];

        service.loadBlocks = loadBlocks;
        service.add = add;

        function loadBlocks () {
            Blocks.getList()
                .then(function(response){
                    response.forEach(function(blk){
                        service.add(blk);
                    });
                }, function(error){
                    console.log('Error loading blocks list: ', error);
                });
        }

        function add (data) {
            data.polygon = createPolygon(data);
            service.blocks.push(data);
            return data;
        }

        function createPolygon(block) {
            var polygon = gmapServices.createCustomPolygon(block.area, service.polygonOptions);

            gmapServices.addListener(polygon, 'click', function() {
                //section.get()
                //    .then(function(sectionResponseObject){
                //        console.log('sectionResponseObject: ', sectionResponseObject);
                //        $mdSidenav('sectionDetailsSidenav')
                //            .open()
                //            .then(function () {
                //                $rootScope.$broadcast('show-section-details', {section: sectionResponseObject});
                                gmapServices.panToPolygon(polygon);
                    //        });
                    //});

            });

            return polygon;
        }

        return service;
    }
}());
(function () {
'use strict';

angular.module('demoApp')
    .factory('alertServices', ['$mdToast', 'SweetAlert', alertServices]);

    function alertServices($mdToast, SweetAlert) {
        var service = {};

        service.showBottomLeftToast = showBottomLeftToast;
        service.showNoDataAvailablePrompt = showNoDataAvailablePrompt;
        service.showEntityNotFound = showEntityNotFound;
        service.showFilterSelectionEmpty = showFilterSelectionEmpty;
        service.showQueryIsEmpty = showQueryIsEmpty;

        function showBottomLeftToast(message) {
            $mdToast.show(
                $mdToast.simple()
                    .textContent(message)
                    .position('bottom left')
                    .hideDelay(2000)
            );
        }

        function showNoDataAvailablePrompt (entityName) {
            service.showBottomLeftToast('No '+ entityName +' data available for this area.');
        }

        function showEntityNotFound(entityName) {
            SweetAlert.swal({
                title: entityName + ' not found.',
                type: 'warning'
            });
        }

        function showFilterSelectionEmpty() {
            SweetAlert.swal({
                title: 'Please select filter type.',
                type: 'warning'
            });
        }

        function showQueryIsEmpty () {
            SweetAlert.swal({
                title: 'Please fill in search query.',
                type: 'info'
            });
        }

        return service;
    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .factory('Sections', ['Restangular', Sections]);

    function Sections(Restangular) {
        var resourceModel = Restangular.all('sections');

        Restangular.extendModel('sections', function (model) {

            model.addBlock = function (block) {
                return model
                    .all('blocks')
                    .customPOST(block);
            };

            return model;
        });

        return resourceModel;
    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .factory('Blocks', ['Restangular', Blocks]);

    function Blocks(Restangular) {
        var resourceModel = Restangular.all('blocks');

        Restangular.extendModel('blocks', function (model) {

            //model.addBlock = function (block) {
            //    return model
            //        .all('blocks')
            //        .customPOST(block);
            //};

            return model;
        });

        return resourceModel;
    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .controller('sectionDetailsController', ['$rootScope', '$mdSidenav', 'sectionList', 'gmapServices', 'drawingServices', 'modalServices', sectionDetailsController]);

    function sectionDetailsController ($rootScope, $mdSidenav, sectionList, gmapServices, drawingServices, modalServices) {
        var vm = this;

        vm.lastPolygon = null;

        vm.editMode = false;
        vm.tempSection = {
            name: null,
            polygon: null,
            area: []
        };

        var saveListener = null;

        vm.section = {
          id: '',
          name: '',
          blocks: [],
          area: []
        };

        vm.initialize = initialize;
        vm.addBlock = addBlock;
        vm.editSection = editSection;
        vm.saveChanges = saveChanges;
        vm.close = close;

        vm.initialize();

        /* Controller Functions here */

        function initialize () {
            $rootScope.$on('show-section-details', function(event, params){
                vm.editMode = false;
                vm.section = params.section;
                //vm.section.blocks = blocks;
                vm.tempSection.name = params.section.name;

                gmapServices.hidePolygon(vm.section.polygon);

                if(vm.lastPolygon) {
                    gmapServices.setEditablePolygon(vm.lastPolygon, false);
                    gmapServices.showPolygon(vm.lastPolygon)
                }

                vm.lastPolygon = vm.section.polygon;

                if(vm.tempSection.polygon) {
                    gmapServices.hidePolygon(vm.tempSection.polygon);
                    vm.tempSection.polygon = null;
                }

                vm.tempSection.polygon = gmapServices.createCustomPolygon(vm.section.area, sectionList.polygonOptions);
            });
        }

        function addBlock (ev) {
            $rootScope.$broadcast('start-drawing');
            drawingServices.startDrawingMode('#e74c3c');

            saveListener = $rootScope.$on('save-area', function (event, param) {
                console.log('save area for block', param.area);
                modalServices.showAddBlock(ev, vm.section, param.area)
                    .then(function (result) {
                        sectionList.add(result.section);
                    }, function (reason) {
                        console.log('failed: ', reason);
                    });
            });
        }

        function editSection () {
            toggle(true);
        }

        function saveChanges () {
            toggle(false);
            vm.tempSection.area = drawingServices.getPolygonCoords(vm.tempSection.polygon);

            // to avoid this error "TypeError: Converting circular structure to JSON"
            vm.section.polygon = null;

            vm.section.area = vm.tempSection.area;
            vm.section.name = vm.tempSection.name;

            vm.section.put()
                .then(function(response){
                    gmapServices.hidePolygon(vm.tempSection.polygon);
                    vm.tempSection.polygon = null;
                    vm.lastPolygon = null;

                    vm.section.polygon = gmapServices.createCustomPolygon(vm.section.area, sectionList.polygonOptions);

                }, function(error){
                    console.log('failed updating section: ',error);
                });
        }

        function toggle(flag) {
            vm.editMode = flag;
            gmapServices.setEditablePolygon(vm.tempSection.polygon, flag);
        }

        function close () {
            $mdSidenav('sectionDetailsSidenav')
                .close()
                .then(function(){
                    vm.section = {
                        id: '',
                        name: '',
                        area: []
                    };
                });
        }

    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .controller('mainController', ['sectionList', 'blockList', mainController]);

    function mainController (sectionList, blockList) {
        var vm = this;

        vm.menu = [
            {
                link: '/admin',
                title: 'Admin',
                icon: 'group'
            },
            {
                link: '/logout',
                title: 'Logout',
                icon: 'exit_to_app'
            }
        ];

        vm.initialize = initialize;

        vm.initialize();

        function initialize () {
            sectionList.loadSections();
            blockList.loadBlocks();
        }

    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .controller('layerController', [layerController]);

    function layerController() {
        var vm = this;

        vm.layers = [
            {
                label: 'Layer1',
                action: 'layerCtl.toggleLayer1()',
                selected: false
            },
            {
                label: 'Layer2',
                action: 'layerCtl.toggleLayer2()',
                selected: false
            },
            {
                label: 'LayerWithChildren1',
                action: '',
                selected: false,
                children: [
                    {
                        label: 'Child1-1',
                        selected: false,
                        action: ''
                    },
                    {
                        label: 'Child1-2',
                        selected: false,
                        action: ''
                    }
                ]
            },
            {
                label: 'LayerWithChildren2',
                action: '',
                selected: false,
                children: [
                    {
                        label: 'Child2-1',
                        selected: false,
                        action: ''
                    },
                    {
                        label: 'Child2-2',
                        selected: false,
                        action: ''
                    }
                ]
            }
        ];


        vm.toggleLayer1 = toggleLayer1;
        vm.toggleLayer2 = toggleLayer2;


        function toggleLayer1 () {
            if (vm.layers[0].selected) {
                console.log('turn on layer1');
            } else {
                console.log('turn off layer1');
            }
        }

        function toggleLayer2 () {
            if (vm.layers[1].selected) {
                console.log('turn on layer2');
            } else {
                console.log('turn off layer2');
            }
        }
        /* Non Scope Functions here */

    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .controller('indexController', ['$rootScope', '$mdSidenav', indexController]);

    function indexController ($rootScope, $mdSidenav) {
        var vm = this;

        // Show Treasure Overlay Spinner
        $rootScope.spinner = {
            active: false
        };

        vm.initialize = initialize;
        vm.toggleLayerPanel = buildToggler('layerPanel');
        vm.toggleSearchPanel = buildToggler('searchPanel');
        vm.closeSideNav = closeSideNav;

        vm.lastSideNavOpenId = '';

        vm.initialize();

        function initialize() {
            console.log('initialize called');
        }

        function buildToggler(navID) {
            return function () {
                if (vm.lastSideNavOpenId && vm.lastSideNavOpenId !== navID) {
                    closeSideNav(vm.lastSideNavOpenId);
                }

                $mdSidenav(navID).toggle();

                vm.lastSideNavOpenId = navID;
            }
        }

        function closeSideNav(navID) {
            $mdSidenav(navID).close();
        }
    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .controller('gmapController', ['$rootScope', 'gmapServices', 'NAV_HEIGHT', gmapController]);

    function gmapController($rootScope, gmapServices, NAV_HEIGHT) {

        var vm = this;

        $rootScope.spinner = {
            active: false
        };

        vm.initialize = initialize;

        vm.initialize();

        function initialize () {
            gmapServices.createMap('map-canvas', NAV_HEIGHT);

            console.log('gmap controller initialized!');
        }

        //function showSolarDetailInfowindow (_solar) {
        //    if(!(_solar && _solar.id)) return;
        //
        //    solarGmapServices.hideSolarMarkers();
        //
        //    var defered = modalServices.showUpdateSolar(_solar, vm, event);
        //    defered.then(function (response) {
        //        console.log('modalServices.showUpdateSolar response:');
        //        console.log(response);
        //
        //            if (!response) return;
        //
        //            solarGmapServices.gmapService.setZoomDefault();
        //            solarGmapServices.showSolarMarkers();
        //
        //            if($rootScope.selectedSolar && response) {
        //                $rootScope.selectedSolar.coordinates = response.coordinates;
        //            }
        //        }, function (errorResponse) {
        //
        //            solarGmapServices.gmapService.setZoomDefault();
        //            solarGmapServices.showSolarMarkers();
        //
        //
        //            console.log('show update solar detail failed');
        //            console.log(errorResponse);
        //        });
        //}
        //
        //
        //function showMarkers () {
        //    solarGmapServices.showSolarMarkers();
        //    solarGmapServices.resetZoom();
        //}

        //function hideMarkers () {
        //    console.log('called from event : modal-opened');
        //    console.log('gmapcontroller hide markers');
        //    solarGmapServices.hideSolarMarkers();
        //    // Hide Solar List Table
        //    $rootScope.showSolarList = false;
        //}
    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .controller('filterController', ['gmapServices', 'alertServices', filterController]);

    function filterController(gmapServices, alertServices) {
        var vm = this;

        vm.filterLayer = '';

        var searchMarker = null;
        var searchInfowindow = null;

        var autocomplete = null;

        vm.initialize = initialize;

        vm.initialize();

        /* Controller Functions here */

        function initialize() {
            autocomplete = gmapServices.initializeAutocomplete('filter-location-input');

            autocomplete.addListener('place_changed', placeChangeCallback);
        }


        //function showResult(data) {
        //    if (!searchInfowindow) searchInfowindow = gmapServices.createInfoWindow('');
        //
        //    if (!searchMarker) {
        //        searchMarker = gmapServices.createCustomMarker(data.coordinates);
        //    } else {
        //        if (!searchMarker.getMap()) gmapServices.showMarker(searchMarker);
        //
        //        searchMarker.setPosition(data.coordinates);
        //    }
        //
        //    searchInfowindow.setContent(data.content);
        //
        //    gmapServices.addListener(searchMarker, 'click', function () {
        //        searchInfowindow.open(gmapServices.map, searchMarker);
        //    });
        //
        //    gmapServices.triggerEvent(searchMarker, 'click');
        //}
        //
        //function hideSearchMarker() {
        //    if (searchMarker && searchMarker.getMap()) {
        //        gmapServices.hideMarker(searchMarker);
        //    }
        //}

        function placeChangeCallback() {
            var place = autocomplete.getPlace();
            if (!place.geometry) {
                alert("Autocomplete's returned place contains no geometry");
                return;
            }
            //console.log('Place Changed!', place);
            // If the place has a geometry, then present it on a map.
            if (place.geometry.viewport) {
                gmapServices.map.fitBounds(place.geometry.viewport);
            } else {
                gmapServices.map.setCenter(place.geometry.location);
                gmapServices.map.setZoom(15);
            }
        }


        /* Non Scope Functions here */

    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .controller('adminGmapController', ['$rootScope', 'gmapServices', adminGmapController]);

    function adminGmapController($rootScope, gmapServices) {

        var vm = this;

        $rootScope.spinner = {
            active: false
        };

        vm.initialize = initialize;

        vm.initialize();

        function initialize () {
            gmapServices.createMap('admin-map-canvas', 0);
        }

    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .controller('adminController', ['$rootScope', '$scope', 'drawingServices', 'modalServices', 'sectionList', adminController]);

    function adminController ($rootScope, $scope, drawingServices, modalServices, sectionList) {
        var vm = this;

        // drawing tools
        vm.drawBtn = {
          save: false,
          delete: false,
          cancel: false
        };

        // save listeners
        var saveListeners = {
            section: null
            //block: null,
            //lot: null
        };

        $rootScope.sections = [];

        vm.initialize = initialize;

        vm.addSection = addSection;
        //vm.addBlock = addBlock;
        //vm.addLot = addLot;

        vm.stopDrawing = stopDrawing;
        vm.saveArea = saveArea;
        vm.deleteSelected = deleteSelected;

        vm.initialize();

        /* Controller Functions here */

        function initialize () {

            $rootScope.$on('start-drawing', function(){
               vm.drawBtn.cancel = true;
            });

            $rootScope.$on('overlay-complete', function () {
                $scope.$apply(function(){
                    vm.drawBtn.save = true;
                    vm.drawBtn.delete = true;
                });
            });
        }

        function addSection (ev) {
            startDrawing();

            saveListeners.section = $scope.$on('save-area', function(event, param){
                modalServices.showAddSection(ev, param.area)
                    .then(function(result){
                        sectionList.add(result.section);
                    }, function(reason){
                        console.log('failed: ',reason);
                    });
            });
        }

        //function addBlock(ev) {
        //    startDrawing();
        //
        //    saveListeners.block = $scope.$on('save-area', function (event, param) {
        //        console.log('save area for block', param.area);
        //    });
        //}
        //
        //function addLot(ev) {
        //    startDrawing();
        //
        //    saveListeners.lot = $scope.$on('save-area', function (event, param) {
        //        console.log('save area for lot', param.area);
        //    });
        //}

        function saveArea() {
            if (!drawingServices.overlay) {
                alert('Cannot proceed. No Overlay Drawn.')
                return;
            }

            var area = drawingServices.overlayDataArray;

            $rootScope.$broadcast('save-area', {area: area});

            vm.stopDrawing();
        }

        function deleteSelected() {
            if (drawingServices.overlay) {
                drawingServices.clearOverlay();
                vm.drawBtn.save = false;
            }
        }

        function stopDrawing () {
            drawingServices.stopDrawingMode();

            // hide draw buttons
            for(var key in vm.drawBtn) vm.drawBtn[key] = false;

            // destroy save listeners
            for (var key in saveListeners) {
                if(saveListeners[key]) {
                    saveListeners[key]();
                    saveListeners[key] = null;
                }
            }
        }

        /* Non Scope Functions here */

        function startDrawing () {
            drawingServices.startDrawingMode();
            // Show Cancel Map button
            vm.drawBtn.cancel = true;
        }

    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .controller('addSectionController', ['$mdDialog', 'area', 'Sections', addSectionController]);

    function addSectionController ($mdDialog, area, Sections) {
        var vm = this;

        vm.section = {
            area: area,
            name: ''
        };

        vm.save = save;
        vm.cancel = cancel;

        /* Controller Functions here */

        function save () {
            Sections.post(vm.section)
                .then(function(response){
                    $mdDialog.hide(response);
                }, function(error){
                    console.log('Error: ', error);
                    // Show Errors
                });
        }

        function cancel () {
            $mdDialog.cancel();
        }

    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .controller('addBlockController', ['$mdDialog', 'section', 'area', addBlockController]);

    function addBlockController ($mdDialog, section, area) {
        var vm = this;

        vm.block = {
            area: area,
            name: ''
        };

        vm.save = save;
        vm.cancel = cancel;

        /* Controller Functions here */

        function save () {
            section.addBlock(vm.block)
                .then(function(response){
                    console.log('Success add block: ',response);
                    $mdDialog.hide(response);
                }, function(error){
                    console.log('Error: ', error);
                });
        }

        function cancel () {
            $mdDialog.cancel();
        }

    }
}());