(function () {
    'use strict';

    angular
        .module('demoApp', ['ngMaterial', 'ngMessages', 'ngAnimate', 'restangular',
            'oitozero.ngSweetAlert', 'treasure-overlay-spinner', 'md.data.table',
            'angularMoment', 'angularInlineEdit'
        ])

        .constant('BASE_URL', window.location.origin)
        .constant('NAV_HEIGHT', 0)

        .config(["$mdThemingProvider", function ($mdThemingProvider) {
            $mdThemingProvider.theme('default')
                .primaryPalette('blue')
                .accentPalette('pink');
        }])

        //.config(['uiMask.ConfigProvider', function (uiMaskConfigProvider) {
        //    uiMaskConfigProvider.maskDefinitions({'*': /[xX0-9]/});
        ////    //uiMaskConfigProvider.clearOnBlur(false);
        ////    //uiMaskConfigProvider.eventsToHandle(['input', 'keyup', 'click']);
        //}])

        .config(['RestangularProvider', function (RestangularProvider) {
            //set the base url for api calls on our RESTful services
            RestangularProvider.setBaseUrl(window.location.origin + '/api');
        }]);

}());


(function(){
'use strict';

angular.module('demoApp')
    .factory('lotHelper', [lotHelper]);

    function lotHelper () {
        var service = {};

        service.computeArea = computeArea;
        service.filterDimensionString = filterDimensionString;

        function validateDimensionArray(dimensionArray) {
            var flag = true,
                lastChar = dimensionArray[0];

            if(isNaN(lastChar)) return false;

            for(var i=1; i < dimensionArray.length; i++) {
                if(isNaN(lastChar) && isNaN(dimensionArray[i])) {
                    flag = false;
                    return;
                }

                lastChar = dimensionArray[i];
            }

            return flag;
        }

        function filterDimensionArray (dimensionArray) {
            function removeNonNumeric(value) {
                return value.length && !isNaN(value);
            }
            return dimensionArray.filter(removeNonNumeric);
        }

        function filterDimensionString (dimension) {
            var dimensionArray = dimension.toLowerCase().split('x');
            return getDimensionString(filterDimensionArray(dimensionArray));
        }

        function getDimensionString(dimensionArray) {
            var dimension = '',
                len = dimensionArray.length;

            dimensionArray.forEach(function(value, index){
                if(index < len - 1) {
                    dimension += value + 'x';
                } else {
                    dimension += value;
                }
            });
            return dimension;
        }

        function computeArea (dimension) {
            if(!dimension) return false;

            var dimensionArray = dimension.toLowerCase().split('x');
            var filteredDimensionArray = filterDimensionArray(dimensionArray);

            if( !validateDimensionArray(dimensionArray)) return false;

            var dimensionStr = getDimensionString(filteredDimensionArray);

            var _area = filteredDimensionArray.length == 2
                     ? parseFloat(filteredDimensionArray[0] * filteredDimensionArray[1])
                     : null;

            //var _area = filteredDimensionArray[0];
            //for(var i=1; i < filteredDimensionArray.length; i++)
            //    _area *= filteredDimensionArray[i];

            dimensionStr += dimensionArray[dimensionArray.length - 1] == ""
                            ? 'x'
                            : '';

            return {
                dimension: dimensionStr,
                area: _area
            };
        }

        return service;
    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .factory('webServices', ["webRequest", webServices]);

    function webServices(webRequest) {
        var service = {};

        /*
        * Meters
        */
        //service.getMeters = function (zoomLevel) {
        //    return webRequest.get('/api/meters');
        //};
        //
        //service.getMeterClustersByZoom = function (zoomLevel) {
        //    return webRequest.get('/api/meters/clusters/zoom/' + zoomLevel);
        //};
        //
        //service.getMeterClustersByZoomAndBounds = function (zoomLevel, bounds) {
        //    return webRequest.get('/api/meters/clusters/zoom/' + zoomLevel + '/bounds/' + bounds);
        //};
        //
        //service.getMetersWithinBounds = function (bounds) {
        //    return webRequest.get('/api/meters/bounds/' + bounds);
        //};
        //
        //service.getMetersByID = function (id) {
        //    return webRequest.get('/api/meters/' + id);
        //};
        //
        //service.getMetersBounds = function () {
        //  return webRequest.get('/api/meters/get_bounds');
        //};
        //
        //service.getMeterByMeterNo = function (meterNo) {
        //    return webRequest.get('/api/meters/get_by_meter_no/' + meterNo);
        //}

        return service;
    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .factory('sectionList', ['$rootScope', '$mdSidenav', 'gmapServices', 'Sections', 'blockList', sectionList]);

    function sectionList ($rootScope, $mdSidenav, gmapServices, Sections, blockList) {
        var service = {};

        service.polygoncolor = '#2c3e50';
        service.polygonOptions = {
            clickable: true,
            fillColor: service.polygoncolor,
            fillOpacity: 0,
            strokeColor: service.polygoncolor,
            strokeOpacity: 0.8,
            strokeWeight: 4,
            zIndex: 100
        };

        service.sections = [];

        service.loadSections = loadSections;
        service.add = add;

        function loadSections (loadForIndex) {
            var forIndex = loadForIndex || false;

            Sections.getList()
                .then(function(response){
                    response.forEach(function(section){
                        service.add(section, forIndex);
                    });
                }, function(error){
                    console.log('Error loading sections list: ',error);
                });
        }

        function add (sectionData, forIndex) {
            sectionData.polygon = createPolygon(sectionData, forIndex);

            blockList.loadBlocksForSection(sectionData, forIndex);

            service.sections.push(sectionData);
            return sectionData;
        }

        function createPolygon(section, forIndex) {
            var polygon = gmapServices.createCustomPolygon(section.area, service.polygonOptions);
                polygon.section = section;

            var adminHandler = function () {
                $mdSidenav('sectionDetailsSidenav')
                    .open()
                    .then(function () {
                        $rootScope.$broadcast('show-section-details', {section: section});
                    });
            };

            var indexHandler = function () {
                console.log('section polygon is clicked handler for index');
                $mdSidenav('sectionDetailsIndexSidenav')
                    .open()
                    .then(function () {
                        $rootScope.$broadcast('show-section-details', {section: section});
                    });
            };

            var handler = forIndex ? indexHandler : adminHandler;

            gmapServices.addListener(
                polygon,
                'click',
                function() {
                    gmapServices.setZoomIfGreater(21);
                    gmapServices.panToPolygon(polygon);
                    handler();
                }
            );

            return polygon;
        }

        return service;
    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .factory('modalServices', ['$mdDialog', '$mdMedia', '$rootScope', '$q', 'Settings', 'Clients', modalServices]);

    function modalServices ($mdDialog, $mdMedia, $rootScope, $q, Settings, Clients) {
        var service = {};

        service.customFullscreen = $mdMedia('sm') || $mdMedia('xs');

        service.settingsModal = null;
        service.showSettings = showSettings;

        service.addSectionModal = null;
        service.addBlockModal = null;
        service.addLotModal = null;

        service.showAddSection = showAddSection;
        service.showAddBlock = showAddBlock;
        service.showAddLot = showAddLot;

        service.showLotDetailModal = null;
        service.showLotDetail = showLotDetail;

        service.showClientSelectionModal = null;
        service.showClientSelection = showClientSelection;

        service.showAddOccupantModal = null;
        service.showAddOccupant = showAddOccupant;

        service.salesReportModal = null;
        service.showSalesReport = showSalesReport;


        function showSettings(event) {
            var dfd = $q.defer();

            if (service.settingsModal) {
                dfd.reject('Modal already opened');
            } else {
                $rootScope.$broadcast("modal-opened");

                Settings.customGET('last_lot_price')
                    .then(function(lastLot){
                        console.log('get last lot price: ',lastLot);

                        service.settingsModal = $mdDialog.show({
                            controller: 'settingsController',
                            controllerAs: 'settingsCtl',
                            templateUrl: 'partials/modals/settings_dialog.tmpl.html',
                            parent: angular.element(document.body),
                            targetEvent: event,
                            locals: {lastLot: lastLot},
                            fullscreen: service.customFullscreen
                        });

                        service.settingsModal.then(
                            function (result) {
                                dfd.resolve(result);
                            }, function (reason) {
                                $rootScope.$broadcast('modal-dismissed');
                                dfd.reject(reason);
                            })
                            .finally(function () {
                                service.settingsModal = null;
                            });

                    }, function(er){
                        console.log('er: ',er);
                    });
            }
            return dfd.promise;
        }

        function showAddSection (event, sectionArea) {
            var dfd = $q.defer();

            if(service.addSectionModal) {
                dfd.reject('Modal already opened');
            } else {
                $rootScope.$broadcast("modal-opened");

                service.addSectionModal = $mdDialog.show({
                    controller: 'addSectionController',
                    controllerAs: 'addSectionCtl',
                    templateUrl: 'partials/modals/add_section_dialog.tmpl.html',
                    parent: angular.element(document.body),
                    locals: {area: sectionArea},
                    targetEvent: event,
                    fullscreen: service.customFullscreen
                });

                service.addSectionModal.then(
                   function(result) {
                    dfd.resolve(result);
                }, function (reason) {
                    $rootScope.$broadcast('modal-dismissed');
                    dfd.reject(reason);
                })
                .finally(function () {
                    service.addSectionModal = null;
                });
            }
            return dfd.promise;
        }

        function showAddBlock(event, section, sectionArea) {
            var dfd = $q.defer();

            if (service.addBlockModal) {
                dfd.reject('Modal already opened');
            } else {
                $rootScope.$broadcast("modal-opened");

                service.addBlockModal = $mdDialog.show({
                    controller: 'addBlockController',
                    controllerAs: 'addBlockCtl',
                    templateUrl: 'partials/modals/add_block_dialog.tmpl.html',
                    parent: angular.element(document.body),
                    locals: {section: section, area: sectionArea},
                    targetEvent: event,
                    fullscreen: service.customFullscreen
                });

                service.addBlockModal.then(
                    function (result) {
                        dfd.resolve(result);
                    }, function (reason) {
                        $rootScope.$broadcast('modal-dismissed');
                        dfd.reject(reason);
                    })
                    .finally(function () {
                        service.addBlockModal = null;
                    });
            }
            return dfd.promise;
        }

        function showAddLot(event, block, area) {
            var dfd = $q.defer();

            if (service.addLotModal) {
                dfd.reject('Modal already opened');
            } else {
                $rootScope.$broadcast("modal-opened");

                service.addLotModal = $mdDialog.show({
                    controller: 'addLotController',
                    controllerAs: 'addLotCtl',
                    templateUrl: 'partials/modals/add_lot_dialog.tmpl.html',
                    parent: angular.element(document.body),
                    locals: {block: block, area: area},
                    targetEvent: event,
                    fullscreen: service.customFullscreen
                });

                service.addLotModal.then(
                    function (result) {
                        dfd.resolve(result);
                    }, function (reason) {
                        $rootScope.$broadcast('modal-dismissed');
                        dfd.reject(reason);
                    })
                    .finally(function(){
                        service.addLotModal = null;
                    })
            }
            return dfd.promise;
        }

        function showLotDetail(lot) {
            var dfd = $q.defer();

            console.log('Show Lot Detail: ', lot);

            if (service.showLotDetailModal) {
                dfd.reject('Modal already opened');
            } else {
                $rootScope.$broadcast("modal-opened");

                lot.get().then(function(result){
                    service.showLotDetailModal = $mdDialog.show({
                        controller: 'lotDetailsController',
                        controllerAs: 'lotDetsCtl',
                        templateUrl: 'partials/modals/lot_details_dialog.tmpl.html',
                        parent: angular.element(document.body),
                        locals: {lot: result},
                        fullscreen: service.customFullscreen
                    });

                    service.showLotDetailModal.then(
                        function (result) {
                            dfd.resolve(result);
                        }, function (reason) {
                            $rootScope.$broadcast('modal-dismissed');
                            dfd.reject(reason);
                        })
                        .finally(function () {
                            service.showLotDetailModal = null;
                        })


                }, function(err){
                    console.log('Error: ',err);
                });

            }
            return dfd.promise;
        }

        function showClientSelection (lot) {
            var dfd = $q.defer();

            if (service.showClientSelectionModal) {
                dfd.reject('Modal already opened');
            } else {
                $rootScope.$broadcast("modal-opened");

                Clients.getList()
                    .then(function(resp) {

                        var clients = [];
                        resp.forEach(function(cl){
                           clients.push(cl);
                        });

                        console.log('Clients: ',resp);

                        service.showClientSelectionModal = $mdDialog.show({
                            controller: 'clientSelectionController',
                            controllerAs: 'clientSelectCtl',
                            templateUrl: 'partials/modals/lot_client_select_dialog.tmpl.html',
                            parent: angular.element(document.body),
                            locals: {lot: lot, clients: clients},
                            fullscreen: service.customFullscreen
                        });

                        service.showClientSelectionModal.then(
                            function (result) {
                                dfd.resolve(result);
                            }, function (reason) {
                                $rootScope.$broadcast('modal-dismissed');
                                dfd.reject(reason);
                            })
                            .finally(function () {
                                service.showClientSelectionModal = null;
                            });

                    }, function(err) {
                        console.log('Error fetching clients: ',err);
                    });
            }
            return dfd.promise;
        }

        function showAddOccupant(lot) {
            var dfd = $q.defer();

            if (service.showAddOccupantModal) {
                dfd.reject('Modal already opened');
            } else {
                $rootScope.$broadcast("modal-opened");

                service.showAddOccupantModal = $mdDialog.show({
                    controller: 'addLotOccupantController',
                    controllerAs: 'addLotOcptCtl',
                    templateUrl: 'partials/modals/add_lot_occupant_dialog.tmpl.html',
                    parent: angular.element(document.body),
                    locals: {lot: lot},
                    fullscreen: service.customFullscreen
                });

                service.showAddOccupantModal.then(
                    function (result) {
                        dfd.resolve(result);
                    }, function (reason) {
                        $rootScope.$broadcast('modal-dismissed');
                        dfd.reject(reason);
                    })
                    .finally(function () {
                        service.showAddOccupantModal = null;
                    });
            }
            return dfd.promise;
        }

        function showSalesReport () {
            var dfd = $q.defer();

            if (service.showAddOccupantModal) {
                dfd.reject('Modal already opened');
            } else {
                $rootScope.$broadcast("modal-opened");

                service.salesReportModal = $mdDialog.show({
                    controller: 'salesReportController',
                    controllerAs: 'salesRepCtl',
                    templateUrl: 'partials/modals/sales_report_dialog.tmpl.html',
                    parent: angular.element(document.body),
                    fullscreen: service.customFullscreen
                });

                service.salesReportModal.then(
                    function (result) {
                        dfd.resolve(result);
                    }, function (reason) {
                        $rootScope.$broadcast('modal-dismissed');
                        dfd.reject(reason);
                    })
                    .finally(function () {
                        service.salesReportModal = null;
                    });
            }
            return dfd.promise;
        }

        return service;
    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .factory('lotList', ['$rootScope', 'gmapServices', 'LOT_COLORS', 'Lots', 'modalServices', lotList]);

    function lotList ($rootScope, gmapServices, LOT_COLORS, Lots, modalServices) {
        var service = {};

        service.selectedLotInfowindow = gmapServices.createInfoWindow('');

        service.polygonColor = LOT_COLORS;
        service.polygonOptions = {
            clickable: true,
            fillOpacity: 0.8,
            strokeColor: '#000000',
            strokeOpacity: 0.6,
            strokeWeight: 1,
            zIndex: 101
        };

        service.lots = [];

        service.loadLotsForBlock = loadLotsForBlock;
        service.add = add;
        service.findLot = findLot;
        service.togglePolygonByStatus = togglePolygonByStatus;
        service.showLotDetailsModal = showLotDetailsModal;

        function initialize() {

            $rootScope.$on('update-lot-detail', function(event, params) {
               var lot = params.lot;

                console.log('Update Lot Detail Event: ', lot);

                var foundLot = service.findLot(lot.block_id, lot.id);
                foundLot.status = lot.status;

                var polygonColor = service.polygonColor[lot.status];
                var polygonOpts = angular.extend({}, service.polygonOptions, {
                    fillColor: polygonColor
                });
                foundLot.polygon.setOptions(polygonOpts);
            });

            $('body').on('click', '.admin-delete-lot-button', function () {
                var lotId = $(this).data('lot-id');
                console.log('delete lot with id = ', lotId);
            });

            $(document).on('click', '.show-lot-detail-button', function () {
                var lotId = $(this).data('lot-id'),
                    blockId = $(this).data('block-id');

                var foundLot = service.findLot(blockId, lotId);

                if (foundLot) {
                    service.showLotDetailsModal(foundLot);
                }
            });
        }

        initialize();

        function loadLotsForBlock (block, forIndex) {
            if(!block.lots) return;

            block.lots.forEach(function(lot){
                service.add(block, lot, forIndex);
            });
        }

        function findLot(blockId, lotId) {
            return _.findWhere(service.lots, {id: lotId, block_id: blockId});
        }

        function add (block, data, forIndex) {
            //if (!service.lots[blockId]) service.lots[blockId] = [];

            //var blockId = block.id;
            data.section_id = block.section_id;
            data.amount = data.lot_area * data.price_per_sq_mtr;
            data.client_name = data.client && data.client.last_name
                               ? (data.client.first_name + ' ' + data.client.last_name)
                               : '';
            data.date_purchased_formatted = moment(data.date_purchased).format("MMM DD, YYYY");

            data.polygon = createPolygon(data, forIndex);

            //service.lots[blockId].push(data);
            service.lots.push(data);
        }

        function createPolygon(lot, forIndex) {
            var polygonColor = service.polygonColor[lot.status];
            var polygonOpts = angular.extend({}, service.polygonOptions, {
               fillColor: polygonColor
            });
            var polygon = gmapServices.createCustomPolygon(lot.area, polygonOpts);

            var restangularizedLot = Lots.cast(lot);


            var adminHandler = function (lot) {
                //console.log('admin handler for polygon click lot');
                //console.log('lot: ', lot);

                var content = '<button data-lot-id="'+lot.id+'" class="md-raised md-button md-ink-ripple" id="admin-delete-lot-button" type="button">Delete Lot</button>';

                var center = gmapServices.getPolygonCenter(lot.polygon);
                gmapServices.showInfoWindow(service.selectedLotInfowindow);
                service.selectedLotInfowindow.setPosition(center);
                service.selectedLotInfowindow.setContent(content);

                $('#admin-delete-lot-button').click(function () {
                    var lotId = $(this).data('lot-id');
                    //console.log('delete lot with id = ', lotId);

                    var polygonTemp = lot.polygon;

                    lot.polygon = null;

                    lot.remove()
                        .then(function(s){
                            gmapServices.hidePolygon(polygonTemp);
                            polygonTemp = null;
                            //console.log('success deleting lot: ', s);
                        },function(e){
                           //console.log('failed to delete lot: ',e);
                           lot.polygon = polygonTemp;
                           alert('Failed to Delete Lot');
                        })
                        .finally(function(){
                            gmapServices.hideInfoWindow(service.selectedLotInfowindow);
                        });
                });
            };

            polygon.lot = lot;

            var indexHandler = function (lot) {
                showLotInfowindow(lot);
            };

            var handler = forIndex ? indexHandler : adminHandler;

            gmapServices.addListener(polygon, 'click', function() {
                gmapServices.setZoomIfGreater(21);
                gmapServices.panToPolygon(polygon);
                handler(this.lot);
            });

            return polygon;
        }

        function togglePolygon(value, polygon) {
            if (value) {
                gmapServices.showPolygon(polygon);
            } else {
                gmapServices.hidePolygon(polygon);
            }
        }

        function showLotDetailsModal (lot) {
            modalServices.showLotDetail(lot)
                .then(function (response) {
                }, function (err) {
                });
        }

        function togglePolygonByStatus(_status, _value) {
            if(_status === 'all') {
                service.lots.forEach(function (lot) {
                    togglePolygon(_value, lot.polygon);
                });
                return;
            }

            var lots = _.where(service.lots, {status: _status});

            lots.forEach(function(lot){
                togglePolygon(_value, lot.polygon);
            });
        }

        var lotInfowindow = gmapServices.createInfoWindow('');

        function showLotInfowindow(lot) {
            var info = '<b>Lot No:</b> ' + (lot.name ? lot.name : 'undefined') + ' <br>';
            info += '<b>Section No:</b> ' + lot.section_id + ' <br>';
            info += '<b>Lot No:</b> ' + lot.id + ' <br>';
            info += '<b>Area:</b> ' + lot.lot_area + ' <br>';
            info += '<b>Amount:</b> ' + lot.amount + ' <br>';
            info += '<b>Status:</b> <span class="' + lot.status + '">' + lot.status + '</span> <br>';
            info += '<b>Date Purchased:</b> ' + lot.date_purchased_formatted + ' <br>';
            info += '<button data-lot-id="' + lot.id + '" data-block-id="' + lot.block_id + '" class="show-lot-detail-button md-primary md-button md-raised">Show Details</button>';

            var center = gmapServices.getPolygonCenter(lot.polygon);
            gmapServices.showInfoWindow(lotInfowindow);
            gmapServices.panTo(center);

            lotInfowindow.setPosition(center);
            lotInfowindow.setContent(info);
        }


        return service;
    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .factory('loaderServices', ['$rootScope', loaderServices]);

    function loaderServices ($rootScope) {
        var service = {};

        service.showLoader = showLoader;
        service.hideLoader = hideLoader;

        function showLoader () {
            $rootScope.spinner.active = true;
        }

        function hideLoader (_doApply) {
            var doApply = _doApply || false;
            if(doApply) {
                $rootScope.$apply(function () {
                    $rootScope.spinner.active = false;
                });
            } else {
                $rootScope.spinner.active = false;
            }
        }
        

        return service;
    }
}());
(function(){
    'use strict';

    angular.module('demoApp')
        .factory('gmapServices', ['$log', '$q', gmapServices]);

    function gmapServices($log, $q) {
        var service = {};

        //infowindow balloons
        service.INFO_WINDOWS = [];

        service.ZOOM_OUT_LEVEL = 8;
        service.ZOOM_IN_LEVEL = 19;

        service.map = null;
        service.mapProjection = null;
        service.overlayView = null;

        service.geocoder = null;

        service.markers = [];

        service.defaultZoom = service.ZOOM_IN_LEVEL;

        service.centerLatLng = new google.maps.LatLng(10.382237, 123.955110);

        // Cluster Objects
        // for Different Layers
        service.markerClusterers = {};

        // Maintain only one infobox
        // Prevent from opening multiple infoboxes
        service.lastInfoboxOpen = null;
        service.infoboxes = [];

        /**
         * Service Functions
         */
        service.apiAvailable = apiAvailable;
        service.createMap = createMap;
        service.createInfoBox = createInfoBox;
        service.openInfoBox = openInfoBox;
        service.closeInfoBox = closeInfoBox;
        service.closeAllInfoBox = closeAllInfoBox;
        service.setMapCursorCrosshair = setMapCursorCrosshair;
        service.setMapBounds = setMapBounds;
        service.getBoundsFromPath = getBoundsFromPath;
        service.setMapCursorDefault = setMapCursorDefault;
        service.addMapListener = addMapListener;
        service.getDistanceOfPath = getDistanceOfPath;
        service.fromLatLngToContainerPixel = fromLatLngToContainerPixel;
        service.fromLatLngToDivPixel = fromLatLngToDivPixel;
        service.fromLatLngToPoint = fromLatLngToPoint;
        service.createCoordinate = createCoordinate;
        service.createInfoWindow = createInfoWindow;
        service.createCanvasInfoWindow = createCanvasInfoWindow;
        service.hideCanvasInfoWindow = hideCanvasInfoWindow;
        service.showInfoWindow = showInfoWindow;
        service.hideInfoWindow = hideInfoWindow;
        service.clearInstanceListeners = clearInstanceListeners;
        service.initMarker = initMarker;
        service.createMarker = createMarker;
        service.createCustomMarker = createCustomMarker;
        service.createCircleMarker = createCircleMarker;
        service.panTo = panTo;
        service.panToOffsetLeft = panToOffsetLeft;
        service.showMarker = showMarker;
        service.showMarkers = showMarkers;
        service.hideMarker = hideMarker;
        service.hideMarkers = hideMarkers;
        service.destroyMarker = destroyMarker;
        service.destroyPolyline = destroyPolyline;
        service.centerMarker = centerMarker;
        service.setMapCenter = setMapCenter;
        service.setMapCenterDefault = setMapCenterDefault;
        service.setZoom = setZoom;
        service.setZoomIfGreater = setZoomIfGreater;
        service.setZoomDefault = setZoomDefault;
        service.setZoomInDefault = setZoomInDefault;
        service.createDrawingManager = createDrawingManager;
        service.createDrawingToolsManager = createDrawingToolsManager;
        service.showDrawingManager = showDrawingManager;
        service.hideDrawingManager = hideDrawingManager;
        service.setEnableDrawingManager = setEnableDrawingManager;
        service.changeDrawingManagerStrokeColor = changeDrawingManagerStrokeColor;
        service.createCircle = createCircle;
        service.updateCircle = updateCircle;
        service.initPolygon = initPolygon;
        service.createPolygon = createPolygon;
        service.createCustomPolygon = createCustomPolygon;
        service.updatePolygon = updatePolygon;
        service.showPolygon = showPolygon;
        service.hidePolygon = hidePolygon;
        service.resetPolygonFill = resetPolygonFill;
        service.fillPolygon = fillPolygon;
        service.getPolygonCenter = getPolygonCenter;
        service.panToPolygon = panToPolygon;
        service.setEditablePolygon = setEditablePolygon;
        service.createPolyline = createPolyline;
        service.createDashedPolyline = createDashedPolyline;
        service.updatePolyline = updatePolyline;
        service.showPolyline = showPolyline;
        service.hidePolyline = hidePolyline;
        service.addListener = addListener;
        service.addListenerOnce = addListenerOnce;
        service.clearInstanceListeners = clearInstanceListeners;
        service.clearListeners = clearListeners;
        service.removeListener = removeListener;
        service.trigger = trigger;
        service.showCurrentLocation = showCurrentLocation;
        service.reverseGeocode = reverseGeocode;
        service.loadKMLByURL = loadKMLByURL;
        service.initMapClusterer = initMapClusterer;
        service.destroyMapClusterer = destroyMapClusterer;
        service.createClusterMarker = createClusterMarker;
        service.getClustererInstance = getClustererInstance;
        service.clearClusterMarkers = clearClusterMarkers;
        service.resetClusters = resetClusters;
        service.insertImageMapType = insertImageMapType;
        service.removeOverlayAtIndex = removeOverlayAtIndex;
        service.initializeAutocomplete = initializeAutocomplete;
        service.containsLocation = containsLocation;
        service.triggerEvent = triggerEvent;

        function apiAvailable() {
            return typeof window.google === 'object';
        }

        function createMap(mapId, navHeight) {
            var _navHeight = navHeight || 0;

            var mapIdLoc = mapId || 'map3d';
            var myMapId = '#' + mapIdLoc;

            if (service.map) return service.map;
            if (!service.apiAvailable()) return null;

            var mapOptions = {
                zoom: service.defaultZoom,
                minZoom: 2,
                center: service.centerLatLng,
                mapTypeControl: false,
                mapTypeId: google.maps.MapTypeId.HYBRID,
                zoomControlOptions: {
                    position: google.maps.ControlPosition.RIGHT_BOTTOM
                },
                panControl: false,
                streetViewControl: false
            };

            $(myMapId).height($(window).height() - (_navHeight));

            service.map = new google.maps.Map(document.getElementById(mapIdLoc), mapOptions);

            // handle window resize event
            google.maps.event.addDomListener(window, 'resize', function () {
                $(myMapId).height($(window).height() - (_navHeight));
                var center = service.map.getCenter();
                google.maps.event.trigger(service.map, 'resize');
                service.map.setCenter(center);
            });

            return service.map;
        }

        function createInfoBox(template) {
            return new InfoBox({
                content: template || '',
                disableAutoPan: true,
                maxWidth: 0,
                pixelOffset: new google.maps.Size(25, -115),
                //closeBoxMargin: '15px 5px',
                closeBoxURL: 'static/resources/images/close-icon.png',
                isHidden: false,
                pane: 'floatPane',
                enableEventPropagation: true
            });
        }

        function openInfoBox(infobox, marker) {
            if( !(service.map && infobox && marker)) return;

            // Close last infobox open
            if (service.lastInfoboxOpen) service.lastInfoboxOpen.close();

            infobox.open(service.map, marker);

            service.lastInfoboxOpen = infobox;
            service.infoboxes.push(infobox);
        }

        function closeAllInfoBox() {
            service.infoboxes.forEach(function(infobox, index) {
               if(infobox) {
                   infobox.close();
               }
            });
        }

        function closeInfoBox() {
            if (service.lastInfoboxOpen) service.lastInfoboxOpen.close();
        }

        function addMapListener(eventName, callback) {
            if (service.map) {
                return service.addListener(service.map, eventName, callback);
            }
            return null;
        }

        function setMapCursorDefault() {
            if (service.map) service.map.setOptions({draggableCursor: null});
        }

        function setMapCursorCrosshair() {
            if (service.map) service.map.setOptions({draggableCursor: 'crosshair'});
        }

        function setMapBounds(bounds) {
            if (service.map) service.map.fitBounds(bounds);
        }

        function getBoundsFromPath(path) {
            if (!service.apiAvailable()) return null;
            var bounds = new google.maps.LatLngBounds();
            for (var index = 0; index < path.length; index++) {
                var point = path[index];
                bounds.extend(point);
            }
            return bounds;
        }

        function getDistanceOfPath(path) {
            if (!service.apiAvailable()) return 0;
            return google.maps.geometry.spherical.computeLength(path);
        }

        function fromLatLngToContainerPixel(latlng) {
            if (service.overlayView) {
                return service.overlayView.getProjection().fromLatLngToContainerPixel(latlng);
            }
            return new google.maps.Point();
        }

        function fromLatLngToDivPixel(latlng) {
            if (service.overlayView) {
                return service.overlayView.getProjection().fromLatLngToDivPixel(latlng);
            }
            return new google.maps.Point();
        }

        function fromLatLngToPoint(latlng) {
            if (service.map) {
                var numTiles = 1 << service.map.getZoom();
                var projection = new MercatorProjection();
                var worldCoordinate = projection.fromLatLngToPoint(latlng);
                return new google.maps.Point(
                    worldCoordinate.x * numTiles,
                    worldCoordinate.y * numTiles
                );
            } else {
                return new google.maps.Point();
            }
        }

        function createCoordinate(latitude, longitude) {
            return new google.maps.LatLng(latitude, longitude);
        }

        function createInfoWindow(content) {
            if (!service.apiAvailable()) return null;
            return new google.maps.InfoWindow({content: content});
        }

        function createCanvasInfoWindow() {
            if (!service.apiAvailable()) return null;

            return new CanvasInfoWindow(service.map);
        }

        function hideCanvasInfoWindow(infoWindow) {
            if (infoWindow) infoWindow.hideInfowindow();
        };

        function showInfoWindow(infoWindow, target) {
            if (infoWindow) infoWindow.open(service.map, target);
        }

        function hideInfoWindow(infoWindow) {
            if (infoWindow) infoWindow.close();
        }

        function clearInstanceListeners(_instance) {
            google.maps.event.clearInstanceListeners(_instance);
        }

        function initMarker(_position, _icon, _opts) {
            if (!service.apiAvailable()) return null;

            var additionalOpts = _opts || {};

            var opts = angular.extend({}, {
                position: _position,
                map: service.map,
                icon: _icon
            }, additionalOpts);

            return new google.maps.Marker(opts);
        }

        function createMarker(_position, _color) {
            _color = _color || service.MARKER_ICONS.RED;
            var marker = service.initMarker(_position, _color);

            service.markers.push(marker);

            return marker;
        }

        function createCustomMarker(_position, _icon, _opts) {
            var opts = _opts || {},
                icon = _icon || 'images/markers/default-marker.png';

            return service.initMarker(_position, icon, opts);
        }

        function createCircleMarker(_position, color) {
            var icon = {
                path: google.maps.SymbolPath.CIRCLE,
                scale: 5,
                fillColor: color || '#6ac1ff',
                fillOpacity: 1,
                strokeColor: 'black',
                strokeWeight: 1
            };

            var marker = service.initMarker(_position, icon);
            service.markers.push(marker);

            return marker;
        }

        function panTo(_position) {
            if (!service.map) return;

            service.map.panTo(_position);
        }

        function panToOffsetLeft(_position, _offset) {
            var offset = _offset || 0.013;
            var latLng = {};

            if(_position instanceof google.maps.LatLng) {
                console.log('object latlng');
                latLng.lat = _position.lat();
                latLng.lng = _position.lng() + offset;
            } else{
                latLng = _position;
                latLng.lng += offset;
            }

            this.panTo(latLng);
        }

        function showMarker(marker) {
            if (marker && marker instanceof google.maps.Marker) marker.setMap(service.map);
        }

        function showMarkers(markerArray) {
            markerArray.forEach(function (marker) {
                service.showMarker(marker);
            });
        }

        function hideMarker(marker) {
            if (marker && marker instanceof google.maps.Marker) marker.setMap(null);
        }

        function hideMarkers(markerArray) {
            markerArray.forEach( function(marker) {
                service.hideMarker(marker);
            });
        }

        function destroyPolyline(polyline) {
            if (polyline && polyline instanceof google.maps.Polyline) polyline.setMap(null);
            service.clearInstanceListeners(polyline);
            polyline = null;
        }

        function destroyMarker(marker) {
            if (marker instanceof Cluster) {
                marker.remove();
            }
            else if (marker instanceof google.maps.Marker) {
                service.hideMarker(marker);
                service.clearInstanceListeners(marker);
            }
            marker = null;
        }

        function centerMarker(marker) {
            if (service.map) {
                service.map.setCenter(marker.position);
            }
        }

        function setMapCenter(coordinates) {
            if (service.map) {
                service.map.setCenter(coordinates);
            }
        }

        function setMapCenterDefault() {
            service.setMapCenter(service.centerLatLng);
        }

        function setZoom(zoomValue) {
            if (service.map) {
                service.map.setZoom(zoomValue);
            }
        }

        function setZoomIfGreater(zoomValue) {
            if (zoomValue > service.map.getZoom())
                service.setZoom(zoomValue);
        }

        function setZoomDefault() {
            service.setZoom(service.defaultZoom);
        }

        function setZoomInDefault() {
            service.setZoom(service.ZOOM_IN_LEVEL);
        }

        function createDrawingManager(_color) {
            if (!service.apiAvailable()) return null;

            var strokeColor = _color || '#0000ff';

            var drawingManager = new google.maps.drawing.DrawingManager({
                drawingMode: null,
                drawingControl: true,
                drawingControlOptions: {
                    position: google.maps.ControlPosition.TOP_CENTER,
                    drawingModes: [
                        google.maps.drawing.OverlayType.POLYGON,
                        google.maps.drawing.OverlayType.RECTANGLE
                    ]
                },
                polygonOptions: {
                    clickable: true,
                    draggable: true,
                    editable: true,
                    geodesic: true,
                    fillColor: '#ffffff',
                    fillOpacity: 0,
                    strokeColor: strokeColor,
                    strokeOpacity: 0.9,
                    strokeWeight: 2,
                    zIndex: 1
                },
                rectangleOptions: {
                    clickable: true,
                    draggable: true,
                    editable: true,
                    fillColor: '#ffffff',
                    fillOpacity: 0,
                    strokeColor: strokeColor,
                    strokeOpacity: 0.9,
                    strokeWeight: 2,
                    zIndex: 1
                }
            });
            service.drawingManager = drawingManager;
            return drawingManager;
        }

        function changeDrawingManagerStrokeColor (color) {
            if (!service.apiAvailable() && !service.drawingManager) return null;

            var _color = color || '#0000ff';

            service.drawingManager.setOptions({
                polygonOptions: {
                    strokeColor: _color
                },
                rectangleOptions: {
                    strokeColor: _color
                }
            });

        }

        function createDrawingToolsManager() {
            if (!service.apiAvailable()) return null;
            var drawingManager = new google.maps.drawing.DrawingManager({
                drawingMode: null,
                drawingControl: true,
                drawingControlOptions: {
                    position: google.maps.ControlPosition.TOP_CENTER,
                    drawingModes: [
                        google.maps.drawing.OverlayType.MARKER,
                        google.maps.drawing.OverlayType.CIRCLE,
                        google.maps.drawing.OverlayType.POLYGON,
                        google.maps.drawing.OverlayType.POLYLINE,
                        google.maps.drawing.OverlayType.RECTANGLE
                    ]
                },
                markerOptions: {
                    icon: service.MARKER_ICONS.RED
                },
                circleOptions: {
                    clickable: true,
                    draggable: false,
                    editable: false,
                    fillColor: '#0000ff',
                    fillOpacity: 0.2,
                    strokeColor: '#0000ff',
                    strokeOpacity: 0.8,
                    strokeWeight: 1,
                    zIndex: 1
                },
                polygonOptions: {
                    clickable: true,
                    draggable: false,
                    editable: false,
                    geodesic: true,
                    fillColor: '#0000ff',
                    fillOpacity: 0.2,
                    strokeColor: '#0000ff',
                    strokeOpacity: 0.8,
                    strokeWeight: 1,
                    zIndex: 1
                },
                polylineOptions: {
                    clickable: true,
                    draggable: false,
                    editable: false,
                    strokeColor: '#0000ff',
                    strokeOpacity: 0.8,
                    strokeWeight: 1,
                    zIndex: 1
                },
                rectangleOptions: {
                    clickable: true,
                    draggable: false,
                    editable: false,
                    fillColor: '#0000ff',
                    fillOpacity: 0.2,
                    strokeColor: '#0000ff',
                    strokeOpacity: 0.8,
                    strokeWeight: 1,
                    zIndex: 1
                }
            });
            service.drawingManager = drawingManager;
            return drawingManager;
        }

        function showDrawingManager(drawingManager) {
            if (drawingManager) {
                if(!drawingManager.getMap()) {
                    drawingManager.setMap(service.map);
                }
                service.setEnableDrawingManager(drawingManager, true);
            }
        }

        function hideDrawingManager(drawingManager) {
            if (drawingManager) {
                drawingManager.setMap(null);
                service.setEnableDrawingManager(drawingManager, false);
            }
        }

        function setEnableDrawingManager(drawingManager, enabled) {
            if (drawingManager) {
                var drawingOptions = {drawingControl: enabled};
                // if drawing mode is disabled, set current mode to hand pointer.
                if (!enabled) drawingOptions['drawingMode'] = null;
                drawingManager.setOptions(drawingOptions);
            }
        }

        function createCircle(latitude, longitude, radius) {
            if (!service.apiAvailable()) return null;
            var latlng = new google.maps.LatLng(latitude, longitude);
            var circleOptions = {
                center: latlng,
                clickable: false,
                draggable: false,
                editable: false,
                fillColor: '#ffffff',
                fillOpacity: 0,
                map: service.map,
                radius: radius,
                strokeColor: '#0000ff',
                strokeOpacity: 0.9,
                strokeWeight: 2,
                zIndex: 100
            };
            return new google.maps.Circle(circleOptions);
        }

        function updateCircle(circle, latitude, longitude, radius) {
            if (circle) {
                circle.setCenter({lat: latitude, lng: longitude});
                circle.setRadius(radius);
            }
        }

        function initPolygon(path, color) {
            if (!service.apiAvailable()) return null;

            var defaultColor = color || '#0000ff';
            var polygonOptions = {
                path: path,
                clickable: false,
                draggable: false,
                editable: false,
                fillColor: defaultColor,
                fillOpacity: 0,
                strokeColor: defaultColor,
                strokeOpacity: 0.9,
                strokeWeight: 2,
                zIndex: 100
            };

            return new google.maps.Polygon(polygonOptions);
        }

        function createCustomPolygon(path, opts) {
            var _opts = {
                path: path,
                map: service.map
            };
            angular.merge(_opts, opts);
            return new google.maps.Polygon(_opts);
        }

        function createPolygon(path, color) {
            var polygon = service.initPolygon(path, color);

            polygon.setMap(service.map);

            return polygon;
        }

        function updatePolygon(polygon, path) {
            if (polygon) polygon.setPath(path);
        }

        function showPolygon(polygon) {
            if (polygon) polygon.setMap(service.map);
        }

        function hidePolygon(polygon) {
            if (polygon) polygon.setMap(null);
        }

        function resetPolygonFill(polygon) {
            polygon.setOptions({
                fillOpacity: 0
            });
        }

        function fillPolygon(polygon) {
            polygon.setOptions({
                fillOpacity: 0.5
            });
        }

        function getPolygonCenter(polygon) {
            if (!service.map || !polygon) return;

            var bounds = new google.maps.LatLngBounds();

            polygon.getPath().forEach(function (path) {
                bounds.extend(path);
            });

            return bounds.getCenter();
        }

        function panToPolygon(polygon) {
            var center = service.getPolygonCenter(polygon);

            service.panTo(center);
        }

        function setEditablePolygon (polygon, flag) {
            var isEditable = flag !== false;

            polygon.setOptions({editable: isEditable, draggable: isEditable});
        }

        function createPolyline(path, lineColor) {
            if (!service.apiAvailable()) return null;
            var polylineOptions = {
                path: path,
                clickable: true,
                draggable: false,
                editable: false,
                map: service.map,
                strokeColor: lineColor || '#ff0000',
                strokeOpacity: 1,
                strokeWeight: 2,
                zIndex: 100
            };
            return new google.maps.Polyline(polylineOptions);
        }

        function createDashedPolyline(path, lineColor) {
            if (!service.apiAvailable()) return null;

            var lineSymbol = {
                path: 'M 0,-1 0,1',
                strokeOpacity: 1,
                scale: 1
            };

            var polylineOptions = {
                path: path,
                clickable: true,
                draggable: false,
                editable: false,
                map: service.map,
                strokeColor: lineColor || '#ff0000',
                icons: [{
                    icon: lineSymbol,
                    offset: '0',
                    repeat: '3px'
                }],
                strokeOpacity: 0,
                zIndex: 100
            };
            return new google.maps.Polyline(polylineOptions);
        }

        function updatePolyline(polyline, path) {
            if (polyline) polyline.setPath(path);
        }

        function showPolyline(polyline) {
            if (polyline) polyline.setMap(service.map);
        }

        function hidePolyline(polyline) {
            if (polyline) polyline.setMap(null);
        }

        function addListener(instance, eventName, handler) {
            if (!service.apiAvailable()) return null;
            return google.maps.event.addListener(instance, eventName, handler);
        }

        function addListenerOnce(instance, eventName, handler, capture) {
            if (!service.apiAvailable()) return null;
            return google.maps.event.addListenerOnce(instance, eventName, handler, capture);
        }

        function clearInstanceListeners(instance) {
            if (service.apiAvailable())
                google.maps.event.clearInstanceListeners(instance);
        }

        function clearListeners(instance, eventName) {
            if (service.apiAvailable())
                google.maps.event.clearListeners(instance, eventName);
        }

        function removeListener(listener) {
            if (service.apiAvailable())
                google.maps.event.removeListener(listener);
        }

        function trigger(instance, eventName, args) {
            if (service.apiAvailable())
                google.maps.event.trigger(instance, eventName, args);
        }

        function showCurrentLocation(_latLng, _isDraggable) {
            var icon = '/images/markers/current-location.png';
            var isDraggable = _isDraggable || false;

            return service.createCustomMarker(_latLng, icon, {draggable: isDraggable});
        }

        function reverseGeocode(latLng) {
            if (!service.geocoder) return;

            var dfd = $q.defer();

            service.geocoder.geocode({'latLng': latLng}, function (results, status) {
                if (status == google.maps.GeocoderStatus.OK) {
                    dfd.resolve(results);
                } else {
                    var error = "Geocoder failed due to: " + status;
                    $log.error(error);
                    dfd.reject(error);
                }
            });

            return dfd.promise;
        }

        function loadKMLByURL(srcUrl, kmlOptions) {
            if (service.map) {
                var opt = {
                    url: srcUrl,
                    map: service.map,
                    preserveViewport: true
                };

                if (kmlOptions) {
                    opt = angular.extend({}, opt, kmlOptions);
                }

                return new google.maps.KmlLayer(opt);
            }
            return null;
        }

        function loadClusterStyles(layerName) {
            var defaultStyle = 'resources/images/cluster_icons/m';

            if(layerName == 'meters') {
                return defaultStyle;
            } else if(layerName == 'transformers') {
                return 'resources/images/cluster_icons/transformers/m';
            } else if(layerName == 'poles') {
                return 'resources/images/cluster_icons/poles/m';
            }
            return defaultStyle;
        }

        function initMapClusterer(layerName) {
            if (!service.markerClusterers[layerName]) {
                var clusterStyle = loadClusterStyles(layerName);

                service.markerClusterers[layerName] = new MarkerClusterer(service.map, [],
                    {imagePath: clusterStyle});

                return service.markerClusterers[layerName];
            }
            return null;
        }

        function destroyMapClusterer(layerName) {
            if (service.markerClusterers[layerName]) {
                service.markerClusterers[layerName] = null;
            }
        }

        function createClusterMarker(_position, clusterCount, layerName) {
            if (!service.apiAvailable() || !service.markerClusterers[layerName]) return null;

            var latLngObj = new google.maps.LatLng(_position.lat, _position.lng)
            var cluster = new Cluster(service.markerClusterers[layerName]);

            cluster.center_ = latLngObj;

            cluster.clusterIcon_.setCenter(latLngObj);
            cluster.clusterIcon_.setSums({text: clusterCount, index: Math.round(Math.log(clusterCount) / Math.LN10)});
            cluster.clusterIcon_.textColor_ = 'white';
            cluster.clusterIcon_.show();
            cluster.clusterIcon_.triggerClusterClick = function () {
                var currentZoom = service.map.getZoom();
                service.map.setZoom(++currentZoom);
                service.map.setCenter(cluster.center_);
            };

            return cluster;
        }

        function getClustererInstance(layerName) {
            return service.markerClusterers[layerName];
        }

        function clearClusterMarkers(clusterArray) {
            clusterArray.forEach(function (item, index) {
                if (item instanceof Cluster) {
                    item.remove();
                }
                clusterArray[index] = null;
            });
        }

        function resetClusters(layerName) {
            if (service.markerClusterers[layerName]) {
                service.markerClusterers[layerName].clusters_ = [];
            }
        }

        function insertImageMapType(srcUrl, insertIndex) {
            if (!service.apiAvailable()) return;

            var _insertIndex = insertIndex || 0;

            var imageTile = new google.maps.ImageMapType({
                getTileUrl: function (coord, zoom) {
                    var z2 = Math.pow(2, zoom);
                    var y = coord.y,
                        x = coord.x >= 0 ? coord.x : z2 + coord.x

                    return srcUrl + '/' + zoom + "/" + x + "/" + y + ".png";
                },
                tileSize: new google.maps.Size(256, 256),
                isPng: true,
                opacity: 1.0
            });

            service.map.overlayMapTypes.insertAt(_insertIndex, imageTile);

            return _insertIndex;
        }

        function removeOverlayAtIndex(index) {
            service.map.overlayMapTypes.setAt(index, null);
        }

        function initializeAutocomplete(elementId) {
            var input = document.getElementById(elementId);
            var autocomplete = new google.maps.places.Autocomplete(input, {
                types: ["geocode"]
            });

            autocomplete.bindTo('bounds', service.map);

            return autocomplete;
        }

        function containsLocation (latLng, polygon) {
            if(!polygon) return;

            return google.maps.geometry.poly.containsLocation(latLng, polygon);
        }

        function triggerEvent (obj, event) {
            google.maps.event.trigger(obj, event);
        }

        return service;
    }
}());


(function () {
    'use strict';

    angular.module('demoApp')
        .factory('drawingServices', ['gmapServices', '$rootScope', drawingServices]);

    function drawingServices(gmapServices, $rootScope) {

        var service = {};
        service.drawingManager = null;
        service.drawingCompleteListener = null;

        service.overlay = null;
        service.overlayType = '';
        service.overlayDataArray = [];

        service.strokeColor = '';

        /**
         * Functions
         */
        service.initDrawingManager = initDrawingManager;
        service.initDrawingListener = initDrawingListener;
        service.setPanControl = setPanControl;
        service.hideDrawingManager = hideDrawingManager;
        service.startDrawingMode = startDrawingMode;
        service.setListenerOfType = setListenerOfType;
        service.stopDrawingMode = stopDrawingMode;
        service.hideOverlay = hideOverlay;
        service.clearOverlay = clearOverlay;
        service.getAreaCoords = getAreaCoords;
        service.getAreaFormData = getAreaFormData;
        service.getPolygonCoords = getPolygonCoords;
        service.getRectangleCorners = getRectangleCorners;
        service.getRectangleCoords = getRectangleCoords;


        function initDrawingManager() {
            if (service.drawingManager) {
                if(service.overlayStrokeColor) gmapServices.changeDrawingManagerStrokeColor(service.overlayStrokeColor);

                // Reinitialize Drawing Listener
                service.initDrawingListener();
                return;
            }

            service.drawingManager = gmapServices.createDrawingManager(service.overlayStrokeColor);
            service.initDrawingListener();
        }


        function initDrawingListener() {
            if (!service.drawingManager) return;

            if (service.drawingCompleteListener) return;

            service.drawingCompleteListener = gmapServices.addListener(
                service.drawingManager, 'overlaycomplete', overlayCompleteListener);
        }


        function overlayCompleteListener(eventArgs) {
            // Set only one overlay
            if (service.overlay) {
                service.overlay.setMap(null);
                service.overlay = null;
                service.overlayDataArray = [];
            }

            service.overlay = eventArgs.overlay;
            service.overlay.setMap(gmapServices.map);

            service.overlayType = eventArgs.type;
            service.overlayDataArray = service.getAreaCoords();

            // Add Listener when overlay is resized
            service.setListenerOfType(eventArgs, function (args) {
                service.overlay = args.overlay;
                service.overlayType = args.type;
                service.overlayDataArray = service.getAreaCoords();
            });

            // Set control to pan every after drawing
            service.setPanControl();

            $rootScope.$broadcast('overlay-complete');
        }


        function setPanControl() {
            service.drawingManager.setDrawingMode(null);
        }


        function hideDrawingManager() {
            if (service.drawingManager) {
                gmapServices.hideDrawingManager(service.drawingManager);
            }
        }

        function startDrawingMode(strokeColor) {
            if(strokeColor) service.overlayStrokeColor = strokeColor;

            service.initDrawingManager();

            gmapServices.showDrawingManager(service.drawingManager);
        }

        function setListenerOfType(eArgs, callbackFn) {
            switch (eArgs.type) {
                // Add Listener Events For Rectangle Changed
                case google.maps.drawing.OverlayType.RECTANGLE:
                    google.maps.event.addListener(eArgs.overlay, 'bounds_changed', function () {
                        callbackFn(eArgs);
                    });
                    break;
                // Add Listener Events For Polygon Changed
                case google.maps.drawing.OverlayType.POLYGON:
                    google.maps.event.addListener(eArgs.overlay.getPath(), 'set_at', function () {
                        callbackFn(eArgs);
                    });
                    google.maps.event.addListener(eArgs.overlay.getPath(), 'insert_at', function (e) {
                        callbackFn(eArgs);
                    });
            }
        }

        function stopDrawingMode() {
            if (service.drawingCompleteListener) {
                gmapServices.removeListener(service.drawingCompleteListener);
                service.drawingCompleteListener = null;
            }

            service.hideDrawingManager();

            service.hideOverlay();
        }

        function cancelDrawingMode() {
            service.stopDrawingMode();
        }

        function hideOverlay() {
            if (!service.overlay) return;

            service.overlay.setMap(null);
            service.overlay = null;
        }

        function clearOverlay() {
            hideOverlay();

            service.overlayDataArray = [];
            service.overlayType = '';
        }

        function getAreaCoords() {
            if (service.overlayType == google.maps.drawing.OverlayType.POLYGON) {
                return service.getPolygonCoords();
            }
            else if (service.overlayType == google.maps.drawing.OverlayType.RECTANGLE) {
                return service.getRectangleCorners();
            }

            return [];
        }

        function getPolygonCoords(_polygon) {
            var polygon = _polygon || service.overlay;

            if (!polygon) return;

            var path = polygon.getPath().getArray();
            var data = [];

            for (var index in path) {
                data.push({
                    lat: path[index].lat(),
                    lng: path[index].lng()
                });
            }

            return data;
        }

        function getAreaFormData(_area) {
            return getPolygonCoords(_area);
        }

        function getRectangleCorners(_rect) {
            var rect = _rect || service.overlay;

            if (!rect) return;

            var bounds = rect.getBounds();
            var min = bounds.getNorthEast();
            var max = bounds.getSouthWest();
            var data = [];

            data.push({lat: min.lat(), lng: min.lng()});
            data.push({lat: max.lat(), lng: min.lng()});
            data.push({lat: max.lat(), lng: max.lng()});
            data.push({lat: min.lat(), lng: max.lng()});

            return data;
        }

        function getRectangleCoords() {
            if (!service.overlay) return;

            var bounds = service.overlay.getBounds();
            var min = bounds.getNorthEast(),
                max = bounds.getSouthWest();
            var data = [];

            data.push({lat: min.lat(), lng: min.lng()});
            data.push({lat: max.lat(), lng: max.lng()});

            return data;
        }

        return service;
    }

}());

(function(){
'use strict';

angular.module('demoApp')
    .factory('blockList', ['lotList', 'gmapServices', blockList]);

    function blockList (lotList, gmapServices) {
        var service = {};

        service.polygoncolor = '#ffffff';
        service.polygonOptions = {
            clickable: true,
            fillColor: service.polygoncolor,
            fillOpacity: 0,
            strokeColor: service.polygoncolor,
            strokeOpacity: 0.3,
            strokeWeight: 2,
            zIndex: 101
        };

        service.blocks = {};

        service.loadBlocksForSection = loadBlocksForSection;
        service.add = add;

        function loadBlocksForSection (section, forIndex) {
            if(!section.blocks) return;

            section.blocks.forEach(function(block){
                service.add(section.id, block, forIndex);
            });
        }

        function add (sectionId, data, forIndex) {
            if (!service.blocks[sectionId]) service.blocks[sectionId] = [];

            // #Note: Remove Polygon for blocks
            // instead lower the opacity #done
            data.polygon = createPolygon(data, forIndex);

            lotList.loadLotsForBlock(data, forIndex);

            service.blocks[sectionId].push(data);
        }

        function createPolygon(block, forIndex) {
            var polygon = gmapServices.createCustomPolygon(block.area, service.polygonOptions);

            var adminHandler = function () {
                console.log('admin handler for polygon click block');
            };

            var indexHandler = function () {
                console.log('index handler for polygon click block');
                //$mdSidenav('blockDetailsIndexSidenav')
                //    .open()
                //    .then(function () {
                //        $rootScope.$broadcast('show-block-details', {block: block});
                //    });
            };

            var handler = forIndex ? indexHandler : adminHandler;

            gmapServices.addListener(polygon, 'click', function() {
                gmapServices.setZoomIfGreater(21);
                gmapServices.panToPolygon(polygon);
                //handler();
            });

            return polygon;
        }

        return service;
    }
}());
(function () {
'use strict';

angular.module('demoApp')
    .factory('alertServices', ['$mdToast', 'SweetAlert', alertServices]);

    function alertServices($mdToast, SweetAlert) {
        var service = {};

        service.showTopRightToast = showTopRightToast;
        service.showLotAdded = showLotAdded;
        service.settingsSuccessfullySaved = settingsSuccessfullySaved;
        service.showErrorMessage = showErrorMessage;

        function showTopRightToast(message) {
            $mdToast.show(
                $mdToast.simple()
                    .textContent(message)
                    .position('top right')
                    .hideDelay(2000)
            );
        }

        function showLotAdded () {
            service.showTopRightToast('Lot Added.');
        }

        function settingsSuccessfullySaved () {
            SweetAlert.swal({
                title: 'Settings Updated!',
                type: 'success'
            });
        }

        function showErrorMessage (error) {
            SweetAlert.swal({
                title: error,
                type: 'error'
            });
        }

        return service;
    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .factory('Settings', ['Restangular', Settings]);

    function Settings(Restangular) {
        var resourceModel = Restangular.all('settings');

        Restangular.extendModel('settings', function (model) {

            model.getLastLotPrice = function () {
                return model
                    .customGET('lastLot_price');
            };

            return model;
        });


        return resourceModel;
    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .factory('Sections', ['Restangular', Sections]);

    function Sections(Restangular) {
        var resourceModel = Restangular.all('sections');

        Restangular.extendModel('sections', function (model) {

            model.addBlock = function (block) {
                return model
                    .all('blocks')
                    .customPOST(block);
            };

            return model;
        });

        return resourceModel;
    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .factory('Lots', ['Restangular', Lots]);

    function Lots(Restangular) {
        var model = Restangular.all('lots');

        Restangular.extendModel('lots', function (model) {

            model.updateDimension = function (dimension) {
                //console.log('update lot dimension: ', dimension);

                return model
                    .all('dimension')
                    .customPUT(dimension);
            };

            model.updatePrice = function (newPrice) {
                console.log('update lot price: ', newPrice);

                return model
                    .all('price')
                    .customPUT(newPrice);
            };

            model.updateORNo = function (ORNo) {
                console.log('update lot or no: ', ORNo);

                return model
                    .all('or_no')
                    .customPUT(ORNo);
            };

            model.updateRemarks = function (data) {
                console.log('update remarks: ', data);

                return model
                    .all('remarks')
                    .customPUT(data);
            };

            model.updateName = function (data) {
                console.log('update name: ', data);

                return model
                    .all('name')
                    .customPUT(data);
            };

            model.updateLotArea = function (data) {
                console.log('update lot area: ', data);

                return model
                    .all('lot_area')
                    .customPUT(data);
            };

            return model;
        });

        return angular.extend(model, {
            cast: function(lot) {
              lot.polygon = null;
              return Restangular.restangularizeElement(null, lot, 'lots');
            }
        });
    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .factory('Clients', ['Restangular', Clients]);

    function Clients(Restangular) {
        var model = Restangular.all('clients');

        return angular.extend(model, {
            cast: function(client) {
              return Restangular.restangularizeElement(null, client, 'clients');
            }
        });
    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .factory('Blocks', ['Restangular', Blocks]);

    function Blocks(Restangular) {
        var model = Restangular.all('blocks');

        return angular.extend(model, {
            cast: function(block) {
              block.polygon = null;
              return Restangular.restangularizeElement(null, block, 'blocks');
            }
        });
    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .directive('allowPattern', [allowPatternDirective]);

    // TODO modify this to allow only digit then "x" alternative
    // ex: 55x6x6x - allowed
    //     555xxx55xxx - not allowed
    function allowPatternDirective() {
        return {
            restrict: "A",
            compile: function (tElement, tAttrs) {
                return function (scope, element, attrs) {
                    // I handle key events
                    element.bind("keypress", function (event) {
                        var keyCode = event.which || event.keyCode; // I safely get the keyCode pressed from the event.
                        var keyCodeChar = String.fromCharCode(keyCode); // I determine the char from the keyCode.

                        // If the keyCode char does not match the allowed Regex Pattern, then don't allow the input into the field.
                        if (!keyCodeChar.match(new RegExp(attrs.allowPattern, "i"))) {
                            event.preventDefault();
                            return false;
                        }

                    });
                };
            }
        };
    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .controller('settingsController', ['$mdDialog', 'Settings', 'alertServices', 'lastLot', settingsController]);

    function settingsController ($mdDialog, Settings, alertServices, lastLot) {
        var vm = this;

        vm.settings = {
            price_per_sq_mtr: ''
        };

        vm.lastLotPrice = {};

        vm.initialize = initialize;
        vm.save = save;
        vm.cancel = cancel;

        vm.initialize();

        /* Controller Functions here */

        function initialize () {
            vm.lastLotPrice = lastLot;
            console.log('lastLotPrice: ',vm.lastLotPrice);
        }

        function save () {
            Settings.post(vm.settings)
                .then(function (response) {
                    console.log('Success saving settings: ',response);
                    alertServices.settingsSuccessfullySaved();
                    $mdDialog.hide(response);
                }, function (error) {
                    console.log('Error: ', error);
                    // Show Errors
                });
        }

        function cancel () {
            $mdDialog.cancel();
        }

        /* Non Scope Functions here */

    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .controller('sectionDetailsIndexController', ['$rootScope', '$mdSidenav', 'sectionList', 'blockList', 'lotList', 'gmapServices', 'drawingServices', 'modalServices', sectionDetailsIndexController]);

    function sectionDetailsIndexController ($rootScope, $mdSidenav, sectionList, blockList, lotList, gmapServices, drawingServices, modalServices) {
        var vm = this;

        vm.lastPolygon = null;

        vm.editMode = false;
        vm.tempSection = {
            name: null,
            polygon: null,
            area: []
        };

        var saveListener = {
            block: null,
            lot: null
        };

        vm.section = {
          id: '',
          name: '',
          blocks: [],
          area: []
        };

        vm.sectionInfo = {
            lotCount: 0,
            soldLot: 0,
            unsoldLot: 0
        };


        vm.initialize = initialize;
        vm.close = close;

        vm.editSection = editSection;
        vm.saveChanges = saveChanges;

        vm.addBlock = addBlock;
        vm.showBlock = showBlock;

        vm.addLot = addLot;
        vm.onLotClick = onLotClick;

        vm.initialize();

        /* Controller Functions here */

        function initialize () {
            $rootScope.$on('show-section-details', function(event, params){
                vm.editMode = false;
                vm.section = params.section;
                vm.tempSection.name = params.section.name;

                updateSectionDetails(vm.section);

                gmapServices.hidePolygon(vm.section.polygon);

                if(vm.lastPolygon) {
                    gmapServices.setEditablePolygon(vm.lastPolygon, false);
                    gmapServices.showPolygon(vm.lastPolygon)
                }

                vm.lastPolygon = vm.section.polygon;

                if(vm.tempSection.polygon) {
                    gmapServices.hidePolygon(vm.tempSection.polygon);
                    vm.tempSection.polygon = null;
                }

                vm.tempSection.polygon = gmapServices.createCustomPolygon(vm.section.area, sectionList.polygonOptions);
            });
        }

        function resetSectionInfo() {
            for (var key in vm.sectionInfo) {
                vm.sectionInfo[key] = 0;
            }
        }

        function updateSectionDetails (section) {
            console.log('section details: ',section);

            resetSectionInfo();

            section.blocks.forEach(function(blk){
                vm.sectionInfo.lotCount += blk.lots.length;
                vm.sectionInfo.soldLot += _.where(blk.lots, {status: 'sold'}).length;
                vm.sectionInfo.soldLot += _.where(blk.lots, {status: 'occupied'}).length;
                vm.sectionInfo.unsoldLot += _.where(blk.lots, {status: 'vacant'}).length;
            });
        }

        /* Section Functions */

        function editSection () {
            toggle(true);
        }

        function saveChanges () {
            toggle(false);
            vm.tempSection.area = drawingServices.getPolygonCoords(vm.tempSection.polygon);

            // to avoid this error "TypeError: Converting circular structure to JSON"
            vm.section.polygon = null;

            vm.section.area = vm.tempSection.area;
            vm.section.name = vm.tempSection.name;

            vm.section.customPUT({area: vm.tempSection.area, name: vm.tempSection.name})
                .then(function(response){
                    gmapServices.hidePolygon(vm.tempSection.polygon);
                    vm.tempSection.polygon = null;
                    vm.lastPolygon = null;

                    vm.section.polygon = gmapServices.createCustomPolygon(vm.section.area, sectionList.polygonOptions);

                }, function(error){
                    console.log('failed updating section: ',error);
                });
        }

        /* End Section Functions */


        /* Block Functions */

        function addBlock(ev) {
            $rootScope.$broadcast('start-drawing');
            drawingServices.startDrawingMode('#e74c3c');

            saveListener.block = $rootScope.$on('save-area', function (event, param) {
                modalServices.showAddBlock(ev, vm.section, param.area)
                    .then(function (result) {
                        blockList.add(result.block.section_id, result.block);
                        vm.section.blocks.push(result.block);
                    }, function (reason) {
                        console.log('failed: ', reason);
                    })
                    .finally(function(){
                        // destroy listener
                        saveListener.block();
                        saveListener.block = null;
                    });
            });
        }

        function showBlock(block) {
            gmapServices.setZoomIfGreater(21);
            gmapServices.panToPolygon(block.polygon);
        }

        /* End of Block Functions */

        /* Lot Functions */

        function addLot(ev, block) {
            $rootScope.$broadcast('start-drawing');
            drawingServices.startDrawingMode('#2ecc71');

            console.log('Block: ',block);

            saveListener.lot = $rootScope.$on('save-area', function (event, param) {
                modalServices.showAddLot(ev, block, param.area)
                    .then(function (result) {
                        lotList.add(block, result.lot);
                        block.lots.push(result.lot);
                    }, function (reason) {
                        console.log('failed: ', reason);
                    })
                    .finally(function () {
                        // destroy listener
                        saveListener.lot();
                        saveListener.lot = null;
                    });
            });
        }

        function onLotClick (lot) {
            var foundLot = lotList.findLot(lot.block_id, lot.id);
            if (foundLot) gmapServices.triggerEvent(foundLot.polygon, 'click');
        }

        /* End of Lot Functions */


        function toggle(flag) {
            vm.editMode = flag;
            gmapServices.setEditablePolygon(vm.tempSection.polygon, flag);
        }

        vm.openBlockMenu = openBlockMenu;
        var originatorEv;

        function openBlockMenu($mdOpenMenu, ev) {
            originatorEv = ev;
            $mdOpenMenu(ev);
        };

        function close () {
            $mdSidenav('sectionDetailsIndexSidenav')
                .close()
                //.then(function(){
                //    vm.section = {
                //        id: '',
                //        name: '',
                //        area: []
                //    };
                //})
            ;
        }

    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .controller('sectionDetailsController', ['$rootScope', '$mdSidenav', 'sectionList', 'blockList', 'lotList', 'gmapServices', 'drawingServices', 'modalServices', sectionDetailsController]);

    function sectionDetailsController ($rootScope, $mdSidenav, sectionList, blockList, lotList, gmapServices, drawingServices, modalServices) {
        var vm = this;

        vm.lastPolygon = null;

        vm.editMode = false;
        vm.tempSection = {
            name: null,
            polygon: null,
            area: []
        };

        var saveListener = {
            block: null,
            lot: null
        };

        vm.section = {
          id: '',
          name: '',
          blocks: [],
          area: []
        };


        vm.initialize = initialize;
        vm.close = close;

        vm.editSection = editSection;
        vm.saveChanges = saveChanges;

        vm.addBlock = addBlock;
        vm.showBlock = showBlock;

        vm.addLot = addLot;

        vm.initialize();

        /* Controller Functions here */

        function initialize () {
            $rootScope.$on('show-section-details', function(event, params){
                vm.editMode = false;
                vm.section = params.section;
                vm.tempSection.name = params.section.name;

                gmapServices.hidePolygon(vm.section.polygon);

                if(vm.lastPolygon) {
                    gmapServices.setEditablePolygon(vm.lastPolygon, false);
                    gmapServices.showPolygon(vm.lastPolygon)
                }

                vm.lastPolygon = vm.section.polygon;

                if(vm.tempSection.polygon) {
                    gmapServices.hidePolygon(vm.tempSection.polygon);
                    vm.tempSection.polygon = null;
                }

                vm.tempSection.polygon = gmapServices.createCustomPolygon(vm.section.area, sectionList.polygonOptions);
            });
        }

        /* Section Functions */

        function editSection () {
            toggle(true);
        }

        function saveChanges () {
            toggle(false);
            vm.tempSection.area = drawingServices.getPolygonCoords(vm.tempSection.polygon);


            console.log('vm.section: ', vm.section);
            // to avoid this error "TypeError: Converting circular structure to JSON"
            vm.section.polygon = null;
            var tempBlocks = vm.section.blocks;
            vm.section.blocks = [];

            vm.section.area = vm.tempSection.area;
            vm.section.name = vm.tempSection.name;

            vm.section.put()
                .then(function(response){
                    gmapServices.hidePolygon(vm.tempSection.polygon);
                    vm.tempSection.polygon = null;
                    vm.lastPolygon = null;

                    vm.section.polygon = gmapServices.createCustomPolygon(vm.section.area, sectionList.polygonOptions);
                }, function(error){
                    console.log('failed updating section: ',error);
                    vm.section.polygon = vm.tempSection.polygon;
                })
                .finally(function(){
                    vm.section.blocks = tempBlocks;
                });
        }

        /* End Section Functions */


        /* Block Functions */

        function addBlock(ev) {
            $rootScope.$broadcast('start-drawing');
            drawingServices.startDrawingMode('#e74c3c');

            saveListener.block = $rootScope.$on('save-area', function (event, param) {
                modalServices.showAddBlock(ev, vm.section, param.area)
                    .then(function (result) {
                        blockList.add(result.block.section_id, result.block);
                        vm.section.blocks.push(result.block);
                    }, function (reason) {
                        console.log('failed: ', reason);
                    })
                    .finally(function(){
                        // destroy listener
                        saveListener.block();
                        saveListener.block = null;
                    });
            });
        }

        function showBlock(block) {
            gmapServices.setZoomIfGreater(21);
            gmapServices.panToPolygon(block.polygon);
        }

        /* End of Block Functions */

        /* Lot Functions */

        function addLot(ev, block) {
            $rootScope.$broadcast('start-drawing');
            drawingServices.startDrawingMode('#2ecc71');

            saveListener.lot = $rootScope.$on('save-area', function (event, param) {
                modalServices.showAddLot(ev, block, param.area)
                    .then(function (result) {
                        lotList.add(block, result.lot);
                        block.lots.push(result.lot);
                    }, function (reason) {
                        console.log('failed: ', reason);
                    })
                    .finally(function () {
                        // destroy listener
                        saveListener.lot();
                        saveListener.lot = null;
                    });
            });
        }

        /* End of Lot Functions */


        function toggle(flag) {
            vm.editMode = flag;
            gmapServices.setEditablePolygon(vm.tempSection.polygon, flag);
        }

        vm.openBlockMenu = openBlockMenu;
        var originatorEv;

        function openBlockMenu($mdOpenMenu, ev) {
            originatorEv = ev;
            $mdOpenMenu(ev);
        };

        function close () {
            $mdSidenav('sectionDetailsSidenav')
                .close()
                //.then(function(){
                //    vm.section = {
                //        id: '',
                //        name: '',
                //        area: []
                //    };
                //})
            ;
        }

    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .controller('salesReportController', ['$scope', '$mdDialog', 'BASE_URL', salesReportController]);

    function salesReportController ($scope, $mdDialog, BASE_URL) {
        var vm = this;

        vm.maxDate = new Date();

        vm.reportDate = {
          start: null,
          end: null
        };

        vm.reportDateData = {
            start: null,
            end: null
        };

        vm.initialize = initialize;
        vm.generateReport = generateReport;
        vm.cancel = cancel;

        vm.initialize();

        /* Controller Functions here */

        function initialize () {
            $scope.$watch(function(){
               return vm.reportDate.start;
            }, function(newValue, oldValue){
                if(newValue === oldValue) return;
                vm.reportDateData.start = parseDate(vm.reportDate.start);
            });

            $scope.$watch(function () {
                return vm.reportDate.end;
            }, function (newValue, oldValue) {
                if (newValue === oldValue) return;
                vm.reportDateData.end = parseDate(vm.reportDate.end);
            });
        }

        function parseDate(date) {
            return date.getFullYear() + '-' + (date.getMonth() + 1) + '-' + date.getDate();
        }

        function getDatesForUrl () {
            return '?start='+vm.reportDateData.start+'&end='+vm.reportDateData.end;
        }

        function generateReport () {
            var datesUrl = getDatesForUrl();
            window.open(BASE_URL + '/reports/sales' + datesUrl);
            $mdDialog.hide();
        }

        function cancel () {
            $mdDialog.cancel();
        }

        /* Non Scope Functions here */

    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .controller('mainController', ['$scope', '$rootScope', 'BASE_URL', 'modalServices', mainController]);

    function mainController ($scope, $rootScope, BASE_URL, modalServices) {
        var vm = this;

        $rootScope.spinner = {
            active: false
        };

        $rootScope.currentUser = {
          username: 'User1',
          role: 'USER'
        };

        vm.menu = [
            {
                link: '/admin',
                title: 'Admin',
                icon: 'group'
            },
            {
                title: 'Settings',
                icon: 'settings'
            },
            {
                link: '/logout',
                title: 'Logout',
                icon: 'exit_to_app'
            }
        ];

        vm.isFabOpen = false;
        vm.tooltipVisible = false;

        vm.initialize = initialize;
        vm.redirect = redirect;
        vm.openSettings = openSettings;

        vm.generateLotListReport = generateLotListReport;
        vm.generateSalesReport = generateSalesReport;

        vm.initialize();

        function initialize () {
            // TODO: fetch logged in user data
            // and add in local storage

            $scope.$watch(function(){
                return vm.isFabOpen;
            }, function(newValue, oldValue){
                if(newValue === oldValue) return;
                vm.tooltipVisible = vm.isFabOpen;
            });
        //    sectionList.loadSections(); // Transferred to Admin Controller
        }

        function redirect(e, link) {
            e.preventDefault();

            if(link == '/admin'  || link == '/logout') {
                console.log('link: ', link);
                window.location = BASE_URL + link;
                return;
            }

            vm.openSettings(e);
        }

        function openSettings (e) {
            modalServices.showSettings(e);
        }

        function generateLotListReport () {
            window.open(BASE_URL + '/reports/lot_list');
        }

        function generateSalesReport () {
            console.log('generate sales report');
            modalServices.showSalesReport();
        }

    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .controller('lotListController', ['$rootScope', '$scope', 'sectionList', 'lotList', 'gmapServices', '$timeout', 'LOT_STATUSES_JSON', lotListController]);

    function lotListController($rootScope, $scope, sectionList, lotList, gmapServices, $timeout, LOT_STATUSES_JSON) {
        var vm = this;

        vm.showList = false;

        // complete list of Solars from the server
        $rootScope.lotList = [];

        $rootScope.lotsDetail = {
            count: {
                all: 0,
                sold: 0,
                vacant: 0,
                occupied: 0
            }
        };

        vm.query = {
            order: 'status',
            limit: 10,
            page: 1,
            filter: ''
        };

        vm.filter = {
            show: false,
            form: null
        };

        vm.searchFilters = {
            section_id: "",
            block_id: "",
            id: "",
            lot_area: "",
            price_per_sq_mtr: "",
            amount: "",
            status: "",
            client_name: "",
            date_purchased_formatted: ""
        };

        vm.searchInfowindow = gmapServices.createInfoWindow('');

        // Table Header
        vm.tableHeaderList = [
            'Section No.',
            'Block No.',
            'Lot No.',
            'Dimension',
            'Area',
            'Amount (Price/SM)',
            'Status',
            'OR #',
            'Owner',
            'Date Purchased',
            'Action'
        ];

        vm.initialize = initialize;
        vm.toggleList = toggleList;
        vm.close = close;
        vm.onClickRow = onClickRow;
        vm.showLotDetails = showLotDetails;
        vm.onReorder = onReorder;
        vm.removeFilter = removeFilter;

        vm.initialize();

        function initialize() {
            sectionList.loadSections(true);

            loadLots();

            $(document).on('click', '.show-lot-detail-button', function () {
                var lotId = $(this).data('lot-id'),
                    blockId = $(this).data('block-id');

                var foundLot = lotList.findLot(blockId, lotId);

                if(foundLot) {
                    vm.searchInfowindow.close();
                    gmapServices.triggerEvent(foundLot.polygon, 'click');
                }
            });

            $scope.$watch(angular.bind(vm, function () {
                return vm.query.filter;
            }), startFilter);

            $rootScope.$watchCollection('lotList', updateLotsDetail);

            $rootScope.$on('toggle-lot-polygons',function (event, params) {
                var status = params.status,
                    value = params.value
                ;

                lotList.togglePolygonByStatus(status, value);
            });
        }

        function toggleList() {
            vm.showList = !vm.showList;
        }

        function updateLotsDetail (newList) {
            $rootScope.lotsDetail.count.all = newList.length;
            $rootScope.lotsDetail.count.vacant = _.where(newList, {status: LOT_STATUSES_JSON.VACANT}).length;
            $rootScope.lotsDetail.count.sold = _.where(newList, {status: LOT_STATUSES_JSON.SOLD}).length;
            $rootScope.lotsDetail.count.occupied = _.where(newList, {status: LOT_STATUSES_JSON.OCCUPIED}).length;
        }

        /* Table Functions */

        function onReorder() {}

        function removeFilter() {
            vm.filter.show = false;
            vm.query.filter = '';

            if (vm.filter.form.$dirty) {
                vm.filter.form.$setPristine();
            }
        }

        function onClickRow(lot) {
            gmapServices.triggerEvent(lot.polygon, 'click');
        }

        function showLotDetails (lot) {
            var foundLot = lotList.findLot(lot.block_id, lot.id);

            if (foundLot) {
                $timeout(function(){
                    vm.searchInfowindow.close();
                }, 300);
                lotList.showLotDetailsModal(foundLot);
            }
        }

        function showSearchedLotInfowindow(lot) {
            var info = '<b>Section No:</b> '+lot.section_id+' <br>';
                info += '<b>Lot No:</b> '+lot.id+' <br>';
                info += '<b>Area:</b> ' + lot.lot_area + ' <br>';
                info += '<b>Amount:</b> ' + lot.amount + ' <br>';
                info += '<b>Status:</b> <span class="'+lot.status+'">' + lot.status + '</span> <br>';
                info += '<b>Date Purchased:</b> ' + lot.date_purchased_formatted + ' <br>';
                info += '<button data-lot-id="'+lot.id+'" data-block-id="'+lot.block_id+'" class="show-lot-detail-button md-primary md-button md-raised">Show Details</button>';

            var center = gmapServices.getPolygonCenter(lot.polygon);
            gmapServices.showInfoWindow(vm.searchInfowindow);
            gmapServices.panTo(center);

            vm.searchInfowindow.setPosition(center);
            vm.searchInfowindow.setContent(info);
        }

        function loadLots() {
            $rootScope.lotList = lotList.lots;
            filterList();
        }

        function startFilter() {
            vm.query.filter = vm.query.filter.toLowerCase();

            for (var key in vm.searchFilters) {
                if (vm.searchFilters.hasOwnProperty(key)) {
                    vm.searchFilters[key] = vm.query.filter;
                }
            }

            filterList();
        }

        function filterList() {
            if (isEmptyFilter()) {
                $rootScope.lots = lotList.lots;
            } else {
                var filtered = manualFilter(vm.searchFilters);
                $rootScope.lots = filtered;
            }
        }

        function manualFilter (searchFilters) {
            var result = [];
            $rootScope.lotList.forEach(function(lot){
                for (var key in searchFilters) {
                    var lotData = String(lot[key]).toLowerCase();
                    if(lotData.indexOf(vm.query.filter) !== -1) {
                        result.push(lot);
                        return;
                    }
                }
            });
            return result;
        }

        function isEmptyFilter() {
            return vm.query.filter === '';
        }

        function close() {
            $mdDialog.hide();
        }
    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .controller('lotDetailsController', ['$scope', '$mdDialog', 'lot', 'modalServices', 'Lots', 'lotHelper', lotDetailsController]);

    function lotDetailsController ($scope, $mdDialog, lot, modalServices, Lots, lotHelper) {
        var vm = this;

        $scope.showEditLotNameForm = false;
        $scope.showEditLotORNoForm = false;
        $scope.showEditLotDimensionForm = false;
        $scope.showEditLotPriceForm = false;
        $scope.showEditLotRemarksForm = false;

        $scope.showEditLotAreaForm = false;

        vm.lot = null;

        vm.lot_copy = null;

        vm.initialize = initialize;
        vm.markSold = markSold;
        vm.addOccupant = addOccupant;
        vm.updateLotORNo = updateLotORNo;
        vm.updateLotDimension = updateLotDimension;
        vm.updateLotPrice = updateLotPrice;
        vm.updateLotRemarks = updateLotRemarks;
        vm.updateLotName = updateLotName;
        vm.updateLotArea = updateLotArea;
        vm.cancel = cancel;

        vm.initialize();

        /* Controller Functions here */

        function initialize () {
            vm.lot = lot;
            vm.lot_copy = angular.copy(vm.lot);
            console.log('lot details: ', vm.lot_copy);

            $scope.$watch(function(){
                return vm.lot;
            }, function(newValue){
                vm.lot_copy = angular.copy(newValue);
            });

            $scope.$watch(function () {
                return vm.lot.lot_area;
            }, computeLotAmount);

            $scope.$watch(function () {
                return vm.lot.price_per_sq_mtr;
            }, computeLotAmount);

            $scope.$watch(function () {
                return vm.lot_copy.dimension;
            }, function (newValue, oldValue) {
                if (newValue == oldValue) return;
                computeLotArea(newValue);
            });

        }

        function computeLotArea(dimension) {
            var result = lotHelper.computeArea(dimension);

            vm.lot_copy.dimension = result.dimension;
            vm.lot_copy.lot_area = result.area;
        }

        function markSold () {
            // TODO show modal to select or add new client and a datepicker to select date sold
            // add functionality to update database
            console.log('mark sold lot');

            modalServices.showClientSelection(vm.lot)
                .then(function(success){
                    console.log('ShowClientSelection: ',success);
                    vm.lot.status = 'sold';
                },function(err){
                    console.log('ShowClientSelection: ', err);
                });
        }

        function addOccupant () {
            console.log('add occupant');
            // add functionality to update database
            modalServices.showAddOccupant(vm.lot)
                .then(function (success) {
                    console.log('Show Add Occupant: ', success);
                }, function (err) {
                    console.log('Show Add Occupant: ', err);
                });
        }

        function updateLotPrice () {
            var newPrice = {price_per_sq_mtr: vm.lot_copy.price_per_sq_mtr};

            console.log('update price request');
            vm.lot.updatePrice(newPrice)
                .then(function (response) {
                    //console.log('success: ',response);

                    var lot = response.lot;
                    vm.lot.price_per_sq_mtr = lot.price_per_sq_mtr;

                    $scope.showEditLotPriceForm = false;

                }, function (error) {
                    console.log('error: ', error);
                });
        }

        function updateLotORNo () {
            console.log('update or no');

            var newORNo = {or_no: vm.lot_copy.or_no};

            vm.lot.updateORNo(newORNo)
                .then(function (response) {
                    //console.log('success: ',response);

                    var lot = response.lot;
                    vm.lot.or_no = lot.or_no;

                    $scope.showEditLotORNoForm = false;

                }, function (error) {
                    console.log('error: ', error);
                });
        }

        function updateLotDimension () {
            var data = {
                dimension: lotHelper.filterDimensionString(vm.lot_copy.dimension),
                lot_area: vm.lot_copy.lot_area
            };

            vm.lot.updateDimension(data)
                .then(function(response){
                    var lot = response.lot;
                    vm.lot.lot_area = lot.lot_area;
                    vm.lot.dimension = lot.dimension;

                    $scope.showEditLotDimensionForm = false;

                }, function(error){
                    console.log('error: ',error);
                });
        }

        function updateLotRemarks () {
            console.log('update lot remarks');

            var data = {remarks: vm.lot_copy.remarks};

            vm.lot.updateRemarks(data)
                .then(function (response) {
                    //console.log('success: ',response);

                    var lot = response.lot;
                    vm.lot.remarks = lot.remarks;

                    $scope.showEditLotRemarksForm = false;

                }, function (error) {
                    console.log('error: ', error);
                });
        }

        function updateLotName () {
            console.log('update lot name');

            var data = {name: vm.lot_copy.name};

            vm.lot.updateName(data)
                .then(function (response) {
                    console.log('success: ',response);
                    var lot = response.lot;
                    vm.lot.name = lot.name;

                    $scope.showEditLotNameForm = false;
                }, function (error) {
                    console.log('error: ', error);
                });
        }


        function updateLotArea() {
            console.log('update lot area');

            var data = {lot_area: vm.lot_copy.lot_area};

            vm.lot.updateLotArea(data)
                .then(function (response) {
                    console.log('success: ', response);
                    var lot = response.lot;
                    vm.lot.lot_area = lot.lot_area;

                    $scope.showEditLotAreaForm = false;
                }, function (error) {
                    console.log('error: ', error);
                });
        }

        function cancel () {
            $mdDialog.cancel();
        }

        function computeLotAmount () {
            vm.lot.amount = parseFloat(vm.lot.price_per_sq_mtr) * parseFloat(vm.lot.lot_area);
        }

    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .controller('clientSelectionController', ['$rootScope', '$scope', 'LOT_STATUSES', '$mdDialog', 'lot', 'clients', 'Clients', 'Lots', clientSelectionController]);

    function clientSelectionController($rootScope, $scope, LOT_STATUSES, $mdDialog, lot, clients, Clients, Lots) {
        var vm = this;

        vm.lot = null;

        vm.clients = clients;
        vm.client = {};
        vm.selectedClient = null;

        vm.lotParam = {
            status: {
                selected: '',
                showMenu: false,
                data: LOT_STATUSES.splice(0, 2)
            }
        };

        vm.initialize = initialize;
        vm.save = save;
        vm.cancel = cancel;
        vm.clearForm = clearForm;

        vm.initialize();

        /* Controller Functions here */

        function initialize() {
            console.log('lot client select controller initialized');

            // cleared data
            vm.rawClient = angular.copy(vm.client);

            vm.lot = lot;

            console.log('lot details: ', vm.lot);
        }

        function save() {
            console.log('Select Client: ',vm.selectedClient);

            var promise = null;

            if( !$scope.selectClientDateForm.$valid) {

                // Show error messages


            } else {
                if (vm.selectedClient) {
                    // update lot with this client id
                    vm.lot.client_id = vm.selectedClient.client_id;
                    promise = vm.lot.put();
                } else {
                    if ($scope.newClientForm.$valid) {
                        vm.client.lot_id = vm.lot.id;

                        vm.lot.client = vm.client;
                        promise = vm.lot.put();
                    }
                }

                promise.then(function (response) {
                    console.log('Select Client: ', response);
                    $mdDialog.hide();
                    // TODO fetch new lot info via http request
                    $rootScope.$broadcast('update-lot-detail', {lot: Lots.cast(response.lot)});
                }, function (err) {
                    console.log('Error adding new client: ', err);
                });
            }
        }

        function cancel() {
            $mdDialog.cancel();
        }

        function clearForm() {
            console.log('clear form');
            vm.client = angular.copy(vm.rawClient);
            $scope.newClientForm.$setPristine();
        }

    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .controller('layerController', [layerController]);

    function layerController() {
        var vm = this;

        vm.layers = [
            {
                label: 'Layer1',
                action: 'layerCtl.toggleLayer1()',
                selected: false
            },
            {
                label: 'Layer2',
                action: 'layerCtl.toggleLayer2()',
                selected: false
            },
            {
                label: 'LayerWithChildren1',
                action: '',
                selected: false,
                children: [
                    {
                        label: 'Child1-1',
                        selected: false,
                        action: ''
                    },
                    {
                        label: 'Child1-2',
                        selected: false,
                        action: ''
                    }
                ]
            },
            {
                label: 'LayerWithChildren2',
                action: '',
                selected: false,
                children: [
                    {
                        label: 'Child2-1',
                        selected: false,
                        action: ''
                    },
                    {
                        label: 'Child2-2',
                        selected: false,
                        action: ''
                    }
                ]
            }
        ];


        vm.toggleLayer1 = toggleLayer1;
        vm.toggleLayer2 = toggleLayer2;


        function toggleLayer1 () {
            if (vm.layers[0].selected) {
                console.log('turn on layer1');
            } else {
                console.log('turn off layer1');
            }
        }

        function toggleLayer2 () {
            if (vm.layers[1].selected) {
                console.log('turn on layer2');
            } else {
                console.log('turn off layer2');
            }
        }
        /* Non Scope Functions here */

    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .controller('indexController', ['$rootScope', '$mdSidenav', indexController]);

    function indexController ($rootScope, $mdSidenav) {
        var vm = this;

        // Show Treasure Overlay Spinner
        $rootScope.spinner = {
            active: false
        };

        vm.initialize = initialize;
        vm.toggleLayerPanel = buildToggler('layerPanel');
        vm.toggleSearchPanel = buildToggler('searchPanel');
        vm.closeSideNav = closeSideNav;

        vm.lastSideNavOpenId = '';

        vm.initialize();

        function initialize() {
            console.log('initialize called');
        }

        function buildToggler(navID) {
            return function () {
                if (vm.lastSideNavOpenId && vm.lastSideNavOpenId !== navID) {
                    closeSideNav(vm.lastSideNavOpenId);
                }

                $mdSidenav(navID).toggle();

                vm.lastSideNavOpenId = navID;
            }
        }

        function closeSideNav(navID) {
            $mdSidenav(navID).close();
        }
    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .controller('gmapController', ['$scope', '$rootScope', 'gmapServices', 'LOT_COLORS', 'NAV_HEIGHT', gmapController]);

    function gmapController($scope, $rootScope, gmapServices, LOT_COLORS, NAV_HEIGHT) {

        var vm = this;

        vm.lotStatusFilters = {
          all: true,
          vacant: true,
          sold: true,
          occupied: true
        };

        vm.showLotLegend = true;
        vm.lotColors = LOT_COLORS;

        vm.getLotsCountByStatus = getLotsCountByStatus;

        $rootScope.spinner = {
            active: false
        };

        vm.initialize = initialize;
        vm.toggleLotLegend = toggleLotLegend;

        vm.initialize();

        function initialize () {
            gmapServices.createMap('map-canvas', NAV_HEIGHT);

            $scope.$watchCollection(function(){
                return vm.lotStatusFilters;
            }, watchLotStatusFilters);

        }

        function watchLotStatusFilters (lotStatusFilters, oldLotStatusFilters) {
            // All Lot Filters
            if(lotStatusFilters.all !== oldLotStatusFilters.all) {
                for(var key in vm.lotStatusFilters) {
                    if(key !== 'all') {
                        vm.lotStatusFilters[key] = lotStatusFilters.all;
                    }
                }

                $rootScope.$broadcast('toggle-lot-polygons', {status: 'all', value: lotStatusFilters.all});
                return;
            }

            for (var key in vm.lotStatusFilters) {
                if (lotStatusFilters[key] !== oldLotStatusFilters[key]) {
                    $rootScope.$broadcast('toggle-lot-polygons', {status: key, value: lotStatusFilters[key]});
                }
            }
        }

        function toggleLotLegend () {
            vm.showLotLegend = !vm.showLotLegend;
        }

        function getLotsCountByStatus (status) {

            return $rootScope.lotsDetail.count[status.toLowerCase()];
        }
    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .controller('filterController', ['gmapServices', 'alertServices', filterController]);

    function filterController(gmapServices, alertServices) {
        var vm = this;

        vm.filterLayer = '';

        var searchMarker = null;
        var searchInfowindow = null;

        var autocomplete = null;

        vm.initialize = initialize;

        vm.initialize();

        /* Controller Functions here */

        function initialize() {
            autocomplete = gmapServices.initializeAutocomplete('filter-location-input');

            autocomplete.addListener('place_changed', placeChangeCallback);
        }


        //function showResult(data) {
        //    if (!searchInfowindow) searchInfowindow = gmapServices.createInfoWindow('');
        //
        //    if (!searchMarker) {
        //        searchMarker = gmapServices.createCustomMarker(data.coordinates);
        //    } else {
        //        if (!searchMarker.getMap()) gmapServices.showMarker(searchMarker);
        //
        //        searchMarker.setPosition(data.coordinates);
        //    }
        //
        //    searchInfowindow.setContent(data.content);
        //
        //    gmapServices.addListener(searchMarker, 'click', function () {
        //        searchInfowindow.open(gmapServices.map, searchMarker);
        //    });
        //
        //    gmapServices.triggerEvent(searchMarker, 'click');
        //}
        //
        //function hideSearchMarker() {
        //    if (searchMarker && searchMarker.getMap()) {
        //        gmapServices.hideMarker(searchMarker);
        //    }
        //}

        function placeChangeCallback() {
            var place = autocomplete.getPlace();
            if (!place.geometry) {
                alert("Autocomplete's returned place contains no geometry");
                return;
            }
            //console.log('Place Changed!', place);
            // If the place has a geometry, then present it on a map.
            if (place.geometry.viewport) {
                gmapServices.map.fitBounds(place.geometry.viewport);
            } else {
                gmapServices.map.setCenter(place.geometry.location);
                gmapServices.map.setZoom(15);
            }
        }


        /* Non Scope Functions here */

    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .controller('blockDetailsIndexController', ['$rootScope', '$mdSidenav', 'sectionList', 'blockList', 'lotList', 'gmapServices', 'drawingServices', blockDetailsIndexController]);

    function blockDetailsIndexController ($rootScope, $mdSidenav, sectionList, blockList, lotList, gmapServices, drawingServices) {
        var vm = this;

        vm.lastPolygon = null;

        vm.editMode = false;
        vm.tempBlock = {
            name: null,
            polygon: null,
            area: []
        };

        var saveListener = {
            lot: null
        };

        vm.block = {
          id: '',
          name: '',
          lots: [],
          area: []
        };

        vm.blockInfo = {
            lotCount: 0,
            soldLot: 0,
            unsoldLot: 0
        };


        vm.initialize = initialize;
        vm.close = close;
        vm.onLotClick = onLotClick;
        vm.showBlock = showBlock;

        vm.initialize();

        /* Controller Functions here */

        function initialize () {
            $rootScope.$on('show-block-details', function(event, params){
                console.log('show block details event ', params.block);
                vm.editMode = false;
                vm.block = params.block;
                vm.tempBlock.name = params.block.name;

                updateBlockDetails(vm.block);

                gmapServices.hidePolygon(vm.block.polygon);

                if(vm.lastPolygon) {
                    gmapServices.setEditablePolygon(vm.lastPolygon, false);
                    gmapServices.showPolygon(vm.lastPolygon)
                }

                vm.lastPolygon = vm.block.polygon;

                if(vm.tempBlock.polygon) {
                    gmapServices.hidePolygon(vm.tempBlock.polygon);
                    vm.tempBlock.polygon = null;
                }

                vm.tempBlock.polygon = gmapServices.createCustomPolygon(vm.block.area, blockList.polygonOptions);
            });
        }

        function resetBlockInfo() {
            for (var key in vm.blockInfo) {
                vm.blockInfo[key] = 0;
            }
        }

        function updateBlockDetails (blk) {
            resetBlockInfo();

            vm.blockInfo.lotCount += blk.lots.length;
            vm.blockInfo.soldLot += _.where(blk.lots, {status: 'sold'}).length;
            vm.blockInfo.soldLot += _.where(blk.lots, {status: 'occupied'}).length;
            vm.blockInfo.unsoldLot += _.where(blk.lots, {status: 'vacant'}).length;
        }

        /* Section Functions */

        function editSection () {
            toggle(true);
        }

        function saveChanges () {
            toggle(false);
            vm.tempSection.area = drawingServices.getPolygonCoords(vm.tempSection.polygon);

            // to avoid this error "TypeError: Converting circular structure to JSON"
            vm.section.polygon = null;

            vm.section.area = vm.tempSection.area;
            vm.section.name = vm.tempSection.name;

            vm.section.put()
                .then(function(response){
                    gmapServices.hidePolygon(vm.tempSection.polygon);
                    vm.tempSection.polygon = null;
                    vm.lastPolygon = null;

                    vm.section.polygon = gmapServices.createCustomPolygon(vm.section.area, sectionList.polygonOptions);

                }, function(error){
                    console.log('failed updating section: ',error);
                });
        }

        /* End Section Functions */


        /* Block Functions */

        function showBlock(block) {
            gmapServices.setZoomIfGreater(21);
            gmapServices.panToPolygon(block.polygon);
        }

        /* End of Block Functions */

        /* Lot Functions */

        function onLotClick(lot) {
            var foundLot = lotList.findLot(lot.block_id, lot.id);
            if (foundLot) gmapServices.triggerEvent(foundLot.polygon, 'click');
        }

        /* End of Lot Functions */


        function toggle(flag) {
            vm.editMode = flag;
            gmapServices.setEditablePolygon(vm.tempSection.polygon, flag);
        }

        vm.openBlockMenu = openBlockMenu;
        var originatorEv;

        function openBlockMenu($mdOpenMenu, ev) {
            originatorEv = ev;
            $mdOpenMenu(ev);
        };

        function close () {
            $mdSidenav('blockDetailsIndexSidenav')
                .close()
            ;
        }

    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .controller('adminGmapController', ['$rootScope', 'gmapServices', adminGmapController]);

    function adminGmapController($rootScope, gmapServices) {

        var vm = this;

        $rootScope.spinner = {
            active: false
        };

        vm.initialize = initialize;

        vm.initialize();

        function initialize () {
            gmapServices.createMap('admin-map-canvas', 0);
        }

    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .controller('adminController', ['$rootScope', '$scope', 'Sections', 'drawingServices', 'modalServices', 'sectionList', adminController]);

    function adminController ($rootScope, $scope, Sections, drawingServices, modalServices, sectionList) {
        var vm = this;

        // drawing tools
        vm.drawBtn = {
          save: false,
          delete: false,
          cancel: false
        };

        // save listeners
        var saveListeners = {
            section: null
        };

        $rootScope.sections = [];

        vm.initialize = initialize;

        vm.addSection = addSection;

        vm.stopDrawing = stopDrawing;
        vm.saveArea = saveArea;
        vm.deleteSelected = deleteSelected;

        vm.initialize();

        /* Controller Functions here */

        function initialize () {
            sectionList.loadSections();

            $rootScope.$on('start-drawing', function(){
               vm.drawBtn.cancel = true;
            });

            $rootScope.$on('overlay-complete', function () {
                $scope.$apply(function(){
                    vm.drawBtn.save = true;
                    vm.drawBtn.delete = true;
                });
            });
        }

        function addSection (ev) {
            startDrawing();

            saveListeners.section = $scope.$on('save-area', function(event, param){
                modalServices.showAddSection(ev, param.area)
                    .then(function(result){
                        // Restangularized Object
                        Sections.get(result.section.id)
                            .then(function (response) {
                                sectionList.add(response);
                            });
                    }, function(reason){
                        console.log('failed: ',reason);
                    })
                    .finally(function(){
                        saveListeners.section();
                        saveListeners.section = null;
                    });
            });
        }

        function saveArea() {
            if (!drawingServices.overlay) {
                alert('Cannot proceed. No Overlay Drawn.')
                return;
            }

            var area = drawingServices.overlayDataArray;

            $rootScope.$broadcast('save-area', {area: area});

            vm.stopDrawing();
        }

        function deleteSelected() {
            if (drawingServices.overlay) {
                drawingServices.clearOverlay();
                vm.drawBtn.save = false;
            }
        }

        function stopDrawing () {
            drawingServices.stopDrawingMode();

            // hide draw buttons
            for(var key in vm.drawBtn) vm.drawBtn[key] = false;

            // destroy save listeners
            for (var key in saveListeners) {
                if(saveListeners[key]) {
                    saveListeners[key]();
                    saveListeners[key] = null;
                }
            }
        }

        /* Non Scope Functions here */

        function startDrawing () {
            drawingServices.startDrawingMode();
            // Show Cancel Map button
            vm.drawBtn.cancel = true;
        }

    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .controller('addSectionController', ['$mdDialog', 'area', 'Sections', addSectionController]);

    function addSectionController ($mdDialog, area, Sections) {
        var vm = this;

        vm.section = {
            area: area,
            name: ''
        };

        vm.save = save;
        vm.cancel = cancel;

        /* Controller Functions here */

        function save () {
            Sections.post(vm.section)
                .then(function(response){
                    $mdDialog.hide(response);
                }, function(error){
                    console.log('Error: ', error);
                    // Show Errors
                });
        }

        function cancel () {
            $mdDialog.cancel();
        }

    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .controller('addLotOccupantController', ['$rootScope', '$scope', '$mdDialog', 'lot', addLotOccupantController]);

    function addLotOccupantController($rootScope, $scope, $mdDialog, lot) {
        var vm = this;

        vm.lot = null;
        vm.occupant = {};

        vm.initialize = initialize;
        vm.save = save;
        vm.cancel = cancel;
        vm.clearForm = clearForm;

        vm.initialize();

        $scope.maxDate = new Date();

        /* Controller Functions here */

        function initialize() {
            vm.lot = lot;
            console.log('lot details: ', vm.lot);
        }

        function save() {
            if($scope.newForm.$valid) {
                vm.lot.post('deceased', vm.occupant)
                    .then(function (response) {
                        console.log('New Deceased: ', response);
                        $mdDialog.hide();
                        // TODO fetch new lot info via http request
                        vm.lot.status = 'occupied'; // TODO extract to constant
                        $rootScope.$broadcast('update-lot-detail', {lot: vm.lot});
                    }, function (err) {
                        console.log('Error adding new deceased: ', err);
                    });
            }
        }

        function cancel() {
            $mdDialog.cancel();
        }

        function clearForm() {
            vm.occupant = {};
            $scope.newForm.$setPristine();
        }

    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .controller('addLotController', ['$scope', '$mdDialog', 'block', 'area', 'Blocks', 'alertServices', 'lotHelper', addLotController]);

    function addLotController ($scope, $mdDialog, block, area, Blocks, alertServices, lotHelper) {
        var vm = this;

        vm.block = null;

        vm.lot = {
            block_id: block.id,
            area: area,
            dimension_width: 0,
            dimension_height: 0,
            lot_area: ''
        };

        vm.initialize = initialize;
        vm.save = save;
        vm.cancel = cancel;

        vm.initialize();

        /* Controller Functions here */

        function initialize () {
            // Restangularized
            vm.block = Blocks.cast(block);

            $scope.$watch(function () {
                return vm.lot.dimension;
            }, function (newValue, oldValue) {
                if (newValue == oldValue) return;
                computeLotArea(newValue);
            });
        }

        function computeLotArea(dimension) {
           var result = lotHelper.computeArea(dimension);

            vm.lot.dimension = result.dimension;
            vm.lot.lot_area = result.area;
        }

        function save () {
            vm.lot.dimension = lotHelper.filterDimensionString(vm.lot.dimension);
            vm.block.post('lots', vm.lot)
                .then(function(response){
                    $mdDialog.hide(response);
                    alertServices.showLotAdded();
                }, function(error){
                    console.log('Error: ', error);
                    alertServices.showErrorMessage(error.data.message);
                });
        }

        function cancel () {
            $mdDialog.cancel();
        }

    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .controller('addBlockController', ['$mdDialog', 'section', 'area', addBlockController]);

    function addBlockController ($mdDialog, section, area) {
        var vm = this;

        vm.block = {
            area: area,
            name: ''
        };

        vm.save = save;
        vm.cancel = cancel;

        /* Controller Functions here */

        function save () {
            //if (typeof section.addBlock == 'function') {

            section.addBlock(vm.block)
                .then(function(response){
                    $mdDialog.hide(response);
                }, function(error){
                    console.log('Error: ', error);
                });

            //} else {
            //    console.log('function section.addBlock doesnt exist!');
            //}
        }

        function cancel () {
            $mdDialog.cancel();
        }

    }
}());
(function(){
    'use strict';

    var lotStatuses = [
        'vacant',
        'sold',
        'occupied'
    ];

    var lotStatusJson = {
        VACANT: 'vacant',
        SOLD: 'sold',
        OCCUPIED: 'occupied'
    };

    var lotColorByStatus = {
        vacant: '#2ecc71',
        sold: '#e74c3c',
        occupied: '#9b59b6'
    };

    var lotDimensions = [
        '3 X 3',
        '3 X 4.5',
        '1.5 X 3',
    ];

    angular.module('demoApp')
        .value('LOT_STATUSES', lotStatuses)
        .value('LOT_STATUSES_JSON', lotStatusJson)
        .value('LOT_DIMENSIONS', lotDimensions)
        .value('LOT_COLORS', lotColorByStatus)
    ;

}());


